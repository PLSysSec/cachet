import "./cacheir.cachet"
import "./masm.cachet"
import "./js.cachet"

fn initRegState();
fn availableReg(reg: Reg);

fn addLiveFloatReg(floatReg: FloatReg);

fn initInputOperandLocation(typedId: TypedId);
fn initValueInputOperandLocation(valueId: ValueId);

fn initValueReg(valueReg: ValueReg);

fn initValueInput(id: ValueId) {
    initValueInputOperandLocation(id);
    let valueReg = CacheIR::defineValueReg(id);
    initValueReg(valueReg);
}

fn initValueTagInputOperandLocation(id: ValueTagId) {
    let typedId = TypedId::fromValueTagId(id);
    initInputOperandLocation(typedId);
}

fn initObjectInput(id: ObjectId) {
    let typedId = TypedId::fromObjectId(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initInt32InputOperandLocation(id: Int32Id) {
    let typedId = TypedId::fromInt32Id(id);
    initInputOperandLocation(typedId);
}

fn initInt32Input(id: Int32Id) {
    let typedId = TypedId::fromInt32Id(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initNumberInput(id: NumberId) {
    let valueId = id as ValueId;
    initValueInput(valueId);
    let valueReg = CacheIR::defineValueReg(valueId);
}

fn initBooleanInput(id: BooleanId) {
    let typedId = TypedId::fromBooleanId(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initStringInput(id: StringId) {
    let typedId = TypedId::fromStringId(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initSymbolInput(id: SymbolId) {
    let typedId = TypedId::fromSymbolId(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initBigIntInput(id: BigIntId) {
    let typedId = TypedId::fromBigIntId(id);
    initInputOperandLocation(typedId);
    let reg = CacheIR::defineReg(typedId);
}

fn initValueOutput() {
    // TODO: assume that outputReg is not one of the registers
    // allocated for the inputs.
    assume TypedOrValueReg::hasValue(CacheIR::outputReg);
    availableReg(ValueReg::scratchReg(TypedOrValueReg::toValueReg(CacheIR::outputReg)));
}

fn initTypedOutput(type: MIRType) {
    // TODO: assume that outputReg is not one of the registers
    // allocated for the inputs.
    assert type != MIRType::Value;
    assume TypedOrValueReg::type(CacheIR::outputReg) == type;
    let anyReg = TypedOrValueReg::toTypedReg(CacheIR::outputReg);
    assume !AnyReg::isFloat(anyReg);
    availableReg(AnyReg::toReg(anyReg));
}
