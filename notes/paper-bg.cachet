/* ... */

struct GetPropIRGenerator;

impl GetPropIRGenerator {
    /* ... */

    fn tryAttachTypedArrayLength(value: Value, valueId: ValueId, key: ProperyKey)
            -> AttachDecision {
        /* ... */

        if !Value::isObject(value) {
            return AttachDecision::NoAction;
        }
        // LEARNED: `value` is an object
        let object = Value::toObject(value); // NEEDED: `value` is an object

        /* ... */

        if !Object::isTypedArrayObject(object) {
            return AttachDecision::NoAction;
        }
        // LEARNED: `object` is a TypedArray
        // LEARNED: if another object has the same shape as `object`, then this implies that the other object is a typed array
        let object = Object::toTypedArrayObject(object); // NEEDED: `object` is a TypedArray

        // Comment out to reproduce bug 1685925.
        if GetPropIRGenerator::mode != ICMode::Specialized {
            return AttachDecision::NoAction;
        }
        // LEARNED: `mode` is `Specialized`

        /* ... */

        let kind = canAttachNativeGetProp(
            object, key, out let maybeHolder, out let maybePropInfo
        );
        if kind != NativeGetPropKind::NativeGetter {
            return AttachDecision::NoAction;
        }
        // LEARNED: `maybeHolder` contains a `NativeObject`
        // LEARNED: `maybePropInfo` contains a `PropertyInfo`
        // LEARNED: ...
        let holder = MaybeNativeObject::toNativeObject(maybeHolder); // NEEDED: `maybeHolder` contains a `NativeObject`
        let propInfo = MaybePropertyInfo::toPropertyInfo(maybePropInfo); // NEEDED: `maybePropInfo` contains a `PropertyInfo`

        let fun = Object::toJSFunction(MaybeObject::toObject(
            NativeObject::getGetter(holder, PropertyInfo::slot(propInfo))
        ));
        if !TypedArrayObject::isOriginalLengthGetter(JSFunction::native(fun)) {
            return AttachDecision::NoAction;
        }
        // LEARNED: the native callback attached to `array.length` (`fun`) is `TypedArray#length`

        /* ... */

        emit CacheIR::GuardToObject(valueId); // (1)
        // *NEEDED: the register corresponding to `valueId` contains a boxed value at runtime
        // *LEARNED: the register corresponding to `valueId` contains a boxed object value at runtime
        let objectId = OperandId::toObjectId(valueId);

        emitCallGetterResultGuards( // (2)
            object, holder, key, propInfo, objectId, GetPropIRGenerator::mode,
        );
        // *LEARNED: if mode is `Specialized`, then the object in the register `objectId` has the same shape as the original `object`
        // ==> *IMPLIES: the object at runtime is also a TypedArray
        // *LEARNED: if mode is NOT `Specialized`, then the object in the register `objectId` has a property `.length` which is a getter pointing to the native `TypedArray#length` callback

        emit CacheIR::LoadArrayLenInt32Result(objectId); // (3) // *NEEDED: the object at runtime is a TypedArray
        emit CacheIR::ReturnFromIC(); // (4)
        return AttachDecision::Attach;
    }

    /* ... */
}

/* ... */

fn emitCallGetterResultGuards(
    object: NativeObject,
    holder: NativeObject,
    key: PropertyKey,
    propInfo: PropertyInfo,
    objectId: ObjectId,
    mode: ICMode,
) emits CacheIR {
    if mode == ICMode::Specialized {
        let shape = Object::shapeOf(object);
        let shapeField = CacheIR::writeShapeField(shape);
        emit CacheIR::GuardShape(objectId, shapeField); // (5)

        /* ... */
    } else {
        let gs = NativeObject::getGetterSetter(holder, PropertyInfo::slot(propInfo));

        let keyField = CacheIR::writePropertyKeyField(key);
        let gsField = CacheIR::writeGetterSetterField(gs);
        emit CacheIR::GuardHasGetterSetter(objectId, keyField, gsField); // (6)
    }
}

/* ... */

language CacheIR {
    /* ... */
    op GuardToObject(inputId: ValueId);
    op GuardShape(objectId: ObjectId, shapeField: ShapeField);
    op GuardHasGetterSetter(
        objectId: ObjectId, keyField: PropertyKeyField, gsField: GetterSetterField
    );
    op LoadArrayLenInt32Result(objectId: ObjectId);
    op ReturnFromIC();
    /* ... */
}

language MASM {
    /* ... */

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM);
    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: JSValueType);

    op BranchTestObjectShape(condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg,
        spectreRegToZero: Reg, label branch: MASM);
    op BranchTestObjectShapeNoSpectreMitigations(condition: Condition, objectReg: Reg,
        shape: Shape, label branch: MASM);

    op BranchIfFalseBool(reg: Reg, label branch: MASM);

    op LoadArrayLenIntPtr(objectReg: Reg, outputReg: Reg);
    op GuardNonNegIntPtrToInt32(reg: Reg, label fail: MASM);
    op TagValue(valTy: JSValueType, payload: Reg, dest: ValueReg);

    /* ... */
}

/* ... */

compiler CacheIRCompiler for CacheIR emits MASM {
    /* ... */

    op GuardToObject(inputId: ValueId) {
        if CacheIRCompiler::knownType(inputId) == JSValueType::Object {
            return;
        }

        let inputReg = CacheIRCompiler::useValueId(inputId);

        let failure = CacheIRCompiler::addFailurePath();

        emit MASM::BranchTestObject(Condition::NotEqual, inputReg, failure.label_); // (7)

        emit MASM::UnboxNonDouble(inputValueReg, ValueReg::scratchReg(inputValueReg), // (8)
            JSValueType::Object);

        CacheIRCompiler::releaseFailurePath();
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField) {
        let objectReg = CacheIRCompiler::useObjectId(objectId);
        let shape = CacheIR::readShapeField(shapeField);

        let maybeScratchReg = MaybeReg::none();
        let needsSpectreMitigations =
            CacheIRCompiler::objectGuardNeedsSpectreMitigations(objectId);
        if needsSpectreMitigations {
            maybeScratchReg = MaybeReg::fromReg(CacheIRCompiler::allocateReg());
        }

        let failure = CacheIRCompiler::addFailurePath();

        if needsSpectreMitigations {
            let scratchReg = MaybeReg::toReg(maybeScratchReg);
            emit MASM::BranchTestObjectShape(Condition::NotEqual, objectReg, shape, scratchReg,
                objectReg, failure.label_); // (9)
            CacheIRCompiler::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjectShapeNoSpectreMitigations(Condition::NotEqual, objectReg,
                shape, failure.label_); // (10)
        }

        CacheIRCompiler::releaseFailurePath();
    }

    op GuardHasGetterSetter(
        objectId: ObjectId, keyField: PropertyKeyField, gsField: GetterSetterField
    ) {
        let objectReg = CacheIRCompiler::useObjectId(objectId);
        let scratchReg = CacheIRCompiler::allocateReg();

        let failure = CacheIRCompiler::addFailurePath();

        /* ... emit MASM ops implementing a call to ObjectHasGetterSetterPure ... */

        emit MASM::BranchIfFalseBool(scratchReg, failure.label_); // (11)

        CacheIRCompiler::releaseReg(scratchReg);
        CacheIRCompiler::releaseFailurePath();
    }

    op LoadArrayLenInt32Result(objectId: ObjectId) {
        let objectReg = CacheIRCompiler::useObjectId(objectId);
        let scratchReg = CacheIRCompiler::allocateReg();

        let failure = CacheIRCompiler::addFailurePath();

        emit MASM::LoadArrayLenIntPtr(objectReg, scratchReg); // (12)
        emit MASM::GuardNonNegIntPtrToInt32(scratchReg, failure.label_); // (13)
        emit MASM::TagValue(JSValueType::Int32, scratchReg, // (14)
            TypedOrValueReg::toValueReg(CacheIRCompiler::outputReg));

        CacheIRCompiler::releaseReg(scratchReg);
        CacheIRCompiler::releaseFailurePath();
    }

    op ReturnFromIC() {}

    /* ... */
}

/* ... */

interpreter MASMInterpreter interprets MASM {
    /* ... */

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASMInterpreter::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal && valueIsObject {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsObject {
            goto branch;
        }
    }

    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: JSValueType) {
        let value = MASMInterpreter::getValue(valueReg);

        if valTy == JSValueType::Object {
            let o = Value::toObject(value);
            MASMInterpreter::setObject(dstReg, o);
        } else if valTy == JSValueType::Int32 {
        /* ... etc ... */
        } else {
            assert unreachable;
        }
    }

    op BranchTestObjectShape(condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg,
            spectreRegToZero: Reg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert objectReg != scratchReg;
        assert spectreRegToZero != scratchReg;

        let object = MASMInterpreter::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASMInterpreter::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(condition: Condition, objectReg: Reg,
            shape: Shape, label branch: MASM) {
        /* ... */
    }

    op BranchIfFalseBool(reg: Reg, label branch: MASM) {
        let b = MASMInterpreter::getBool(reg);

        if !b {
            goto branch;
        }
    }

    op LoadArrayLenIntPtr(objectReg: Reg, outputReg: Reg) {
        let baseObject = MASMInterpreter::getObject(objectReg);
        let offset = TypedArrayObject::lengthOffset();

        let data = Object::readData(baseObject, offset);
        MASMInterpreter::setData(outputReg, data);
    }

    op GuardNonNegIntPtrToInt32(reg: Reg, label fail: MASM) {
        let value = RegData::toValue(MASMInterpreter::getData(reg));
        if !Value::isDouble(value) {
            goto fail;
        }

        let ptr = Value::toPrivate(value);
        if ptr > 0xffffffff {
            goto fail;
        }

        let int32 = ptr as Int32;
        MASMInterpreter::setInt32(reg, int32);
    }

    op TagValue(valTy: JSValueType, payload: Reg, dest: ValueReg) {
        if valTy == JSValueType::Object {
            let o = MASMInterpreter::getObject(payload);
            let val = Value::fromObject(o);
            MASMInterpreter::setValue(dest, val);
        } else if valTy == JSValueType::Int32 {
        /* ... etc ... */
        } else {
            assert unreachable;
        }
    }

    /* ... */
}

/* ... */

struct Object;

impl Object {
    /* ... */

    fn readData(object: Object, offset: Int64) -> RegData {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);

        if Class::isNativeObject(class) {
            let nativeObject = unsafe { object as NativeObject };
            return NativeObject::readData(nativeObject, offset);
        }

        assert unreachable;
    }

    fn isTypedArrayObject(object: Object) -> Bool {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        Class::isTypedArrayObject(class)
    }
    
    /* ... */
}

/* ... */

struct NativeObject <: Object;

impl NativeObject {
    /* ... */

    fn readData(nativeObject: NativeObject, offset: Int64) -> RegData {
        if offset == NativeObject::offsetOfSlots as Int64 {
            // dynamic slots array
            let slots = NativeObject::getSlots(nativeObject);
            return RegData::fromNativeObjectSlots(slots);
        } else if offset == NativeObject::offsetOfElements as Int64 {
            // object elements
            let elements = NativeObject::getElementsHeader(nativeObject);
            return RegData::fromNativeObjectElements(elements);
        } else if offset >= NativeObject::offsetOfFixedSlots as Int64 {
            // fixed slots
            let slotOffset = offset as UInt64 - NativeObject::sizeOf;
            assert slotOffset % Value::sizeOf == 0_u64;
            assert slotOffset / Value::sizeOf < Shape::fixedSlotLimit;

            let slot = (slotOffset / Value::sizeOf) as UInt32;
            let value = NativeObject::getFixedSlot(nativeObject, slot);
            return RegData::fromValue(value);
        } else {
            assert unreachable;
        }
    }

    fn offsetOfFixedSlot(slot: UInt32) -> UInt64 {
        NativeObject::offsetOfFixedSlots + slot * Value::sizeOf
    }

    #[reads(heap)]
    unsafe fn getFixedSlot(nativeObject: NativeObject, slot: UInt32) -> Value;

    refine safe fn getFixedSlot(nativeObject: NativeObject, slot: UInt32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert slot < Shape::numFixedSlots(shape);

        unsafe { raw NativeObject::getFixedSlot(nativeObject, slot) }
    }

    /* ... */
}

/* ... */

struct Shape;

impl Shape {
    /* ... */

    fn classOf(shape: Shape) -> Class;

    fn numFixedSlots(shape: Shape) -> UInt32;
    refine fn numFixedSlots(shape: Shape) -> UInt32 {
        let numFixedSlots = raw Shape::numFixedSlotsUnchecked(shape);

        assume numFixedSlots < Shape::numFixedSlotsLimit;
        assume numFixedSlots >= Class::numReservedSlots(Shape::classOf(shape));

        numFixedSlots
    }

    /* ... */
}

/* ... */

struct Class;

impl Class {
    /* ... */

    fn numReservedSlots(class: Class) -> UInt32;

    fn isTypedArrayObject(class: Class) -> Bool;
    refine fn isTypedArrayObject(class: Class) -> Bool {
        let result = raw Class::isTypedArrayObject(class);
        if result {
            assume Class::isNativeObject(class);
            assume Class::numReservedSlots(class) == TypedArrayObject::reservedSlots;
        }
        result
    }

    /* ... */
}

/* ... */

struct TypedArrayObject;

impl TypedArrayObject {
    /* ... */

    var lengthSlot: UInt32 = 1_u32;
    var reservedSlots: UInt32 = 4_u32;

    fn lengthOffset() -> Int32 {
        NativeObject::offsetOfFixedSlot(TypedArrayObject::lengthSlot) as Int32
    }

    /* ... */
}

/* ... */
