// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

enum DataType {
    Value,
    UnboxedValue,
    NativeObjectSlots,
    NativeObjectElements,
    TypeTag,
    TaggedProto,
    Class,
    StackIndex,
}

struct Data;

impl Data {
    fn typeOf(data: Data) -> DataType;

    fn isValue(data: Data) -> Bool {
        Data::typeOf(data) == DataType::Value
    }

    fn fromValue(value: Value) -> Data {
        let data = (unsafe { Data::fromValueUnchecked(value) });
        assume Data::isValue(data);
        assume (unsafe { Data::toValueUnchecked(data) }) == value;
        data
    }

    unsafe fn fromValueUnchecked(value: Value) -> Data;

    fn toValue(data: Data) -> Value {
        assert Data::isValue(data);
        let value = (unsafe { Data::toValueUnchecked(data) });
        assume (unsafe { Data::fromValueUnchecked(value) }) == data;
        value
    }

    unsafe fn toValueUnchecked(data: Data) -> Value;

    fn isUnboxedValue(data: Data) -> Bool {
        Data::typeOf(data) == DataType::UnboxedValue
    }

    fn fromUnboxedValue(value: Value) -> Data {
        let data = (unsafe { Data::fromUnboxedValueUnchecked(value) });
        assume Data::isUnboxedValue(data);
        assume (unsafe { Data::toUnboxedValueUnchecked(data) }) == value;
        data
    }

    unsafe fn fromUnboxedValueUnchecked(value: Value) -> Data;

    fn toUnboxedValue(data: Data) -> Value {
        assert Data::isUnboxedValue(data);
        let value = (unsafe { Data::toUnboxedValueUnchecked(data) });
        assume (unsafe { Data::fromUnboxedValueUnchecked(value) }) == data;
        value
    }

    unsafe fn toUnboxedValueUnchecked(data: Data) -> Value;

    fn isNativeObjectSlots(data: Data) -> Bool {
        Data::typeOf(data) == DataType::NativeObjectSlots
    }

    fn fromNativeObjectSlots(slots: NativeObjectSlots) -> Data {
        let data = (unsafe { Data::fromNativeObjectSlotsUnchecked(slots) });
        assume Data::isNativeObjectSlots(data);
        assume (unsafe { Data::toNativeObjectSlotsUnchecked(data) }) == slots;
        data
    }

    unsafe fn fromNativeObjectSlotsUnchecked(slots: NativeObjectSlots) -> Data;

    fn toNativeObjectSlots(data: Data) -> NativeObjectSlots {
        assert Data::isNativeObjectSlots(data);
        let slots = (unsafe { Data::toNativeObjectSlotsUnchecked(data) });
        assume (unsafe { Data::fromNativeObjectSlotsUnchecked(slots) }) == data;
        slots
    }

    unsafe fn toNativeObjectSlotsUnchecked(data: Data) -> NativeObjectSlots;

    fn isNativeObjectElements(data: Data) -> Bool {
        Data::typeOf(data) == DataType::NativeObjectElements
    }

    fn fromNativeObjectElements(elements: NativeObjectElements) -> Data {
        let data = (unsafe { Data::fromNativeObjectElementsUnchecked(elements) });
        assume Data::isNativeObjectElements(data);
        assume (unsafe { Data::toNativeObjectElementsUnchecked(data) }) == elements;
        data
    }

    unsafe fn fromNativeObjectElementsUnchecked(slots: NativeObjectElements) -> Data;

    fn toNativeObjectElements(data: Data) -> NativeObjectElements {
        assert Data::isNativeObjectElements(data);
        let elements = (unsafe { Data::toNativeObjectElementsUnchecked(data) });
        assume (unsafe { Data::fromNativeObjectElementsUnchecked(elements) }) == data;
        elements
    }

    unsafe fn toNativeObjectElementsUnchecked(data: Data) -> NativeObjectElements;

    fn isTypeTag(data: Data) -> Bool {
        Data::typeOf(data) == DataType::TypeTag
    }

    fn fromValueType(valTy: ValueType) -> Data {
        let data = (unsafe { Data::fromValueTypeUnchecked(valTy) });
        assume Data::isTypeTag(data);
        assume (unsafe { Data::toValueTypeUnchecked(data) }) == valTy;
        data
    }

    unsafe fn fromValueTypeUnchecked(valTy: ValueType) -> Data;

    fn toValueType(data: Data) -> ValueType {
        assert Data::isTypeTag(data);
        let valTy = (unsafe { Data::toValueTypeUnchecked(data) });
        assume (unsafe { Data::fromValueTypeUnchecked(valTy) }) == data;
        valTy
    }

    unsafe fn toValueTypeUnchecked(data: Data) -> ValueType;

    fn isTaggedProto(data: Data) -> Bool {
        Data::typeOf(data) == DataType::TaggedProto
    }

    fn fromTaggedProto(proto: TaggedProto) -> Data {
        let data = (unsafe { Data::fromTaggedProtoUnchecked(proto) });
        assume Data::isTaggedProto(data);
        assume (unsafe { Data::toTaggedProtoUnchecked(data) }) == proto;
        data
    }

    unsafe fn fromTaggedProtoUnchecked(proto: TaggedProto) -> Data;

    fn toTaggedProto(data: Data) -> TaggedProto {
        assert Data::isTaggedProto(data);
        let proto = (unsafe { Data::toTaggedProtoUnchecked(data) });
        assume (unsafe { Data::fromTaggedProtoUnchecked(proto) }) == data;
        proto
    }

    unsafe fn toTaggedProtoUnchecked(data: Data) -> TaggedProto;

    fn isClass(data: Data) -> Bool {
        Data::typeOf(data) == DataType::Class
    }

    fn fromClass(class: Class) -> Data {
        let data = (unsafe { Data::fromClassUnchecked(class) });
        assume Data::isClass(data);
        assume (unsafe { Data::toClassUnchecked(data) }) == class;
        data
    }

    unsafe fn fromClassUnchecked(class: Class) -> Data;

    fn toClass(data: Data) -> Class {
        assert Data::isClass(data);
        let class = (unsafe { Data::toClassUnchecked(data) });
        assume (unsafe { Data::fromClassUnchecked(class) }) == data;
        class
    }

    unsafe fn toClassUnchecked(data: Data) -> Class;

    fn isStackIndex(data: Data) -> Bool {
        Data::typeOf(data) == DataType::StackIndex
    }

    fn fromStackIndex(index: UInt64) -> Data {
        let data = (unsafe { Data::fromStackIndexUnchecked(index) });
        assume Data::isStackIndex(data);
        assume (unsafe { Data::toStackIndexUnchecked(data) }) == index;
        data
    }

    unsafe fn fromStackIndexUnchecked(index: UInt64) -> Data;

    fn toStackIndex(data: Data) -> UInt64 {
        assert Data::isStackIndex(data);
        let index = (unsafe { Data::toStackIndexUnchecked(data) });
        assume (unsafe { Data::fromStackIndexUnchecked(index) }) == data;
        index
    }

    unsafe fn toStackIndexUnchecked(data: Data) -> UInt64;

    fn readData(data: Data, offset: Int64) -> Data {
        if Data::isUnboxedValue(data) {
            let value = Data::toUnboxedValue(data);
            return Value::readData(value, offset);
        } else if Data::isNativeObjectSlots(data) {
            let slots = Data::toNativeObjectSlots(data);
            return NativeObjectSlots::readData(slots, offset);
        } else if Data::isNativeObjectElements(data) {
            let elements = Data::toNativeObjectElements(data);
            return NativeObjectElements::readData(elements, offset);
        }

        assert false;
        data // returning to satisfy compiler
    }
}

fn runtimeMainContextPtr() -> Data;

enum MIRType {
    Undefined,
    Null,
    Boolean,
    Int32,
    Int64,
    IntPtr,
    Double,
    Float32,

    String,
    Symbol,
    BigInt,
    Simd128,

    Object,
    MagicOptimizedOut,
    MagicHole,
    MagicIsConstructing,
    MagicUninitializedLexical,

    Value,
    None,
    Slots,
    Elements,
    Pointer,
    RefOrNull,
    StackResults,
    Shape,
}

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
  Unknown,
}

impl ValueType {
    fn fromMIRType(type: MIRType) -> ValueType {
        if type == MIRType::Undefined {
            return ValueType::Undefined;
        } else if type == MIRType::Null {
            return ValueType::Null;
        } else if type == MIRType::Boolean {
            return ValueType::Bool;
        } else if type == MIRType::Int32 {
            return ValueType::Int32;
        } else if type == MIRType::Float32 || type == MIRType::Double {
            return ValueType::Double;
        } else if type == MIRType::String {
            return ValueType::String;
        } else if type == MIRType::Symbol {
            return ValueType::Symbol;
        } else if type == MIRType::BigInt {
            return ValueType::BigInt;
        } else if type == MIRType::MagicOptimizedOut || type == MIRType::MagicHole || type ==
        MIRType::MagicIsConstructing || type == MIRType::MagicUninitializedLexical {
            return ValueType::Magic;
        }

        assert type == MIRType::Object;
        ValueType::Object
    }
}

struct Value;

impl Value {
    var sizeOf: UInt64 = 8_u64;

    fn typeOf(value: Value) -> ValueType;

    // ...

    fn isDouble(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Double
    }

    fn fromDouble(double: Double) -> Value {
        let value = (unsafe { Value::fromDoubleUnchecked(double) });
        assume Value::isDouble(value);
        assume (unsafe { Value::toDoubleUnchecked(value) }) == double;
        value
    }

    unsafe fn fromDoubleUnchecked(value: Double) -> Value;

    fn toDouble(value: Value) -> Double {
        assert Value::isDouble(value);
        let double = (unsafe { Value::toDoubleUnchecked(value) });
        assume (unsafe { Value::fromDoubleUnchecked(double) }) == value;
        double
    }

    unsafe fn toDoubleUnchecked(value: Value) -> Double;

    fn isInt32(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Int32
    }

    fn fromInt32(int32: Int32) -> Value {
        let value = (unsafe { Value::fromInt32Unchecked(int32) });
        assume Value::isInt32(value);
        assume (unsafe { Value::toInt32Unchecked(value) }) == int32;
        value
    }

    unsafe fn fromInt32Unchecked(value: Int32) -> Value;

    fn toInt32(value: Value) -> Int32 {
        assert Value::isInt32(value);
        let int32 = (unsafe { Value::toInt32Unchecked(value) });
        assume (unsafe { Value::fromInt32Unchecked(int32) }) == value;
        int32
    }

    unsafe fn toInt32Unchecked(value: Value) -> Int32;

    fn isBool(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Bool
    }

    fn fromBool(bool: Bool) -> Value {
        let value = (unsafe { Value::fromBoolUnchecked(bool) });
        assume Value::isBool(value);
        assume (unsafe { Value::toBoolUnchecked(value) }) == bool;
        value
    }

    unsafe fn fromBoolUnchecked(value: Bool) -> Value;

    fn toBool(value: Value) -> Bool {
        assert Value::isBool(value);
        let bool = (unsafe { Value::toBoolUnchecked(value) });
        assume (unsafe { Value::fromBoolUnchecked(bool) }) == value;
        bool
    }

    unsafe fn toBoolUnchecked(value: Value) -> Bool;

    fn isNull(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Null
    }

    fn isUndefined(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Undefined
    }

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = (unsafe { Value::fromObjectUnchecked(object) });
        assume Value::isObject(value);
        assume (unsafe { Value::toObjectUnchecked(value) }) == object;
        value
    }

    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = (unsafe { Value::toObjectUnchecked(value) });
        assume (unsafe { Value::fromObjectUnchecked(object) }) == value;
        object
    }

    unsafe fn toObjectUnchecked(value: Value) -> Object;

    fn isMagic(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Magic
    }

    fn isString(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::String
    }

    fn fromString(string: String) -> Value {
        let value = (unsafe { Value::fromStringUnchecked(string) });
        assume Value::isString(value);
        assume (unsafe { Value::toStringUnchecked(value) }) == string;
        value
    }

    unsafe fn fromStringUnchecked(string: String) -> Value;

    fn toString(value: Value) -> String {
        assert Value::isString(value);
        let string = (unsafe { Value::toStringUnchecked(value) });
        assume (unsafe { Value::fromStringUnchecked(string) }) == value;
        string
    }

    unsafe fn toStringUnchecked(value: Value) -> String;

    fn isSymbol(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Symbol
    }

    fn fromSymbol(symbol: Symbol) -> Value {
        let value = (unsafe { Value::fromSymbolUnchecked(symbol) });
        assume Value::isSymbol(value);
        assume (unsafe { Value::toSymbolUnchecked(value) }) == symbol;
        value
    }

    unsafe fn fromSymbolUnchecked(symbol: Symbol) -> Value;

    fn toSymbol(value: Value) -> Symbol {
        assert Value::isSymbol(value);
        let symbol = (unsafe { Value::toSymbolUnchecked(value) });
        assume (unsafe { Value::fromSymbolUnchecked(symbol) }) == value;
        symbol
    }

    unsafe fn toSymbolUnchecked(value: Value) -> Symbol;

    fn isBigInt(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::BigInt
    }

    fn fromBigInt(bigInt: BigInt) -> Value {
        let value = (unsafe { Value::fromBigIntUnchecked(bigInt) });
        assume Value::isBigInt(value);
        assume (unsafe { Value::toBigIntUnchecked(value) }) == bigInt;
        value
    }

    unsafe fn fromBigIntUnchecked(bigInt: BigInt) -> Value;

    fn toBigInt(value: Value) -> BigInt {
        assert Value::isBigInt(value);
        let bigInt = (unsafe { Value::toBigIntUnchecked(value) });
        assume (unsafe { Value::fromBigIntUnchecked(bigInt) }) == value;
        bigInt
    }

    unsafe fn toBigIntUnchecked(value: Value) -> BigInt;

    fn readData(value: Value, offset: Int64) -> Data {
        if Value::isObject(value) {
            let object = Value::toObject(value);
            return Object::readData(object, offset);
        }

        assert false; // Only support Object for now
        return Data::fromValue(value);
    }
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn shapeOf(object: Object) -> Shape;
    fn shapeOf(object: Object) -> Shape {
        (unsafe { Object::shapeOfUnchecked(heap, object) })
    }

    unsafe fn shapeOfUnchecked(heap: Heap, object: Object) -> Shape;

    

    fn toNativeObject(object: Object) -> NativeObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isNativeObject(class);
        (unsafe { object as NativeObject })
    }

    fn toArgumentsObject(object: Object) -> ArgumentsObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isArgumentsObject(class);
        (unsafe { object as ArgumentsObject })
    }
  
    fn getFixedSlot(object: Object, slot: UInt32) -> Value {
        let nativeObject = Object::toNativeObject(object);
        NativeObject::getFixedSlot(nativeObject, slot)
    }

    // read Data at the specified memory offset of the Object
    fn readData(object: Object, offset: Int64) -> Data {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);   

        if Class::isNativeObject(class) {
            let nativeObject = (unsafe { object as NativeObject });
            return NativeObject::readData(nativeObject, offset);
        }
        
        assert false; // only support NativeObject for now
        return Data::fromValue(Value::fromObject(object)); // satisfy the compiler
    }
}

struct NativeObject <: Object;

impl NativeObject {
    var maxFixedSlots: UInt64 = 16_u64;
    var sizeOf: UInt64 = 24_u64;
    var offsetOfSlots: UInt64 = 8_u64;
    var offsetOfElements: UInt64 = 16_u64;

    fn getFixedSlot(nativeObject: NativeObject, slot: UInt32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert Shape::hasFixedSlot(shape, slot);
        (unsafe { NativeObject::getFixedSlotUnchecked(heap, nativeObject, slot) })
    }

    // #[reads(heap)]
    // unsafe fn getFixedSlotUnchecked(nativeObject: NativeObject, slot: UInt32) -> Value;
    unsafe fn getFixedSlotUnchecked(heap: Heap, nativeObject: NativeObject, slot: UInt32) ->
    Value;

    fn getSlots(nativeObject: NativeObject) -> NativeObjectSlots {
        let slots = (unsafe { NativeObject::getSlotsUnchecked(heap, nativeObject) } );
        let shape = Object::shapeOf(nativeObject); 
        assume NativeObjectSlots::length(slots) == 
            (Shape::slotSpan(shape) - Shape::numFixedSlots(shape));
        slots
    }

    unsafe fn getSlotsUnchecked(heap: Heap, nativeObject: NativeObject) -> NativeObjectSlots;

    fn getElementsHeader(nativeObject: NativeObject) -> NativeObjectElements {
        (unsafe { NativeObject::getElementsHeaderUnchecked(heap, nativeObject) } )
    }

    unsafe fn getElementsHeaderUnchecked(heap: Heap, nativeObject: NativeObject) ->
    NativeObjectElements;

    fn readData(nativeObject: NativeObject, offset: Int64) -> Data {
        if offset == NativeObject::offsetOfSlots as Int64 {
            // dynamic slots array
            let slots = NativeObject::getSlots(nativeObject);
            return Data::fromNativeObjectSlots(slots);
        } else if offset == NativeObject::offsetOfElements as Int64 {
            // object elements
            let elements = NativeObject::getElementsHeader(nativeObject); 
            return Data::fromNativeObjectElements(elements);
        } else if offset >= NativeObject::sizeOf as Int64 {
            // fixed slots
            let slotOffset = offset as UInt64 - NativeObject::sizeOf;
            assert slotOffset % Value::sizeOf == 0_u64;
            assert slotOffset / Value::sizeOf < NativeObject::maxFixedSlots;
            let slot = (slotOffset / Value::sizeOf) as UInt32;
            let value = NativeObject::getFixedSlot(nativeObject, slot);
            return Data::fromValue(value);
        }

        assert false;
        return Data::fromValue(Value::fromObject(nativeObject as Object)); // satisfy the compiler
    }
}

struct NativeObjectSlots;

impl NativeObjectSlots {
    fn length(slots: NativeObjectSlots) -> UInt32;

    fn getDynamicSlot(slots: NativeObjectSlots, slot: UInt32) -> Value {
        assert slot < NativeObjectSlots::length(slots);
        (unsafe { NativeObjectSlots::getDynamicSlotUnchecked(heap, slots, slot) } )
    }

    unsafe fn getDynamicSlotUnchecked(heap: Heap, slots: NativeObjectSlots, slot: UInt32) ->
    Value;

    fn readData(slots: NativeObjectSlots, offset: Int64) -> Data {
        assert offset % Value::sizeOf as Int64 == 0_i64;
        let slot = (offset / Value::sizeOf as Int64) as UInt32;
        let value = NativeObjectSlots::getDynamicSlot(slots, slot);
        Data::fromValue(value)
    }
}

struct NativeObjectElements;

impl NativeObjectElements {
    var offsetOfLength: Int32 = -4_i32;
    var offsetOfInitializedLength: Int32 = -12_i32;

    fn getLength(elements: NativeObjectElements) -> UInt32 {
        ( unsafe { NativeObjectElements::getLengthUnchecked(heap, elements) } )
    }

    unsafe fn getLengthUnchecked(heap: Heap, elements: NativeObjectElements) -> UInt32;

    fn getInitializedLength(elements: NativeObjectElements) -> UInt32 {
        ( unsafe { NativeObjectElements::getInitializedLengthUnchecked(heap, elements) } )
    }

    // TODO: can initializedLength be changed ?
    unsafe fn getInitializedLengthUnchecked(heap: Heap, elements: NativeObjectElements) -> UInt32;


    fn readData(elements: NativeObjectElements, offset: Int64) -> Data {
        if offset == NativeObjectElements::offsetOfLength {
            let length = NativeObjectElements::getLength(elements);
            let value = Value::fromInt32(length as Int32);
            return Data::fromValue(value);
        } else if offset == NativeObjectElements::offsetOfInitializedLength {
            let initializedLength = NativeObjectElements::getInitializedLength(elements);
            let value = Value::fromInt32(initializedLength as Int32);
            return Data::fromValue(value);
        }

        assert false;
        Data::fromNativeObjectElements(elements)
    }
}

struct JSFunction <: NativeObject;

struct ArrayObject <: NativeObject;

impl ArrayObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(ArrayObject::rawClass);
        ArrayObject::rawClass
    }
}

struct PlainObject <: NativeObject;

impl PlainObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(PlainObject::rawClass);
        PlainObject::rawClass
    }
}

struct ArrayBufferObjectMaybeShared <: NativeObject;

struct ArrayBufferObject <: ArrayBufferObjectMaybeShared;

impl ArrayBufferObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(ArrayBufferObject::rawClass);
        ArrayBufferObject::rawClass
    }
}

struct SharedArrayBufferObject <: ArrayBufferObjectMaybeShared;

impl SharedArrayBufferObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(SharedArrayBufferObject::rawClass);
        SharedArrayBufferObject::rawClass
    }
}

struct ArrayBufferViewObject <: NativeObject;

struct DataViewObject <: ArrayBufferViewObject;

impl DataViewObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(DataViewObject::rawClass);
        DataViewObject::rawClass
    }
}

struct ArgumentsObject <: NativeObject;

impl ArgumentsObject {
    var lengthOverridenBit : UInt32 = 1_u32;
    var packedBitsCount: UInt32 = 5_u32;

    fn getInitialLength(obj: ArgumentsObject) -> UInt32;
}

struct UnmappedArgumentsObject <: ArgumentsObject;

impl UnmappedArgumentsObject {
    var rawClass : Class;

    fn class() -> Class {
        assume Class::isNativeObject(UnmappedArgumentsObject::rawClass);
        UnmappedArgumentsObject::rawClass
    }
}

struct MappedArgumentsObject <: ArgumentsObject;

impl MappedArgumentsObject {
    var rawClass: Class;

    fn class() -> Class {
        assume Class::isNativeObject(MappedArgumentsObject::rawClass);
        MappedArgumentsObject::rawClass
    }
}

struct SetObject <: NativeObject;

impl SetObject {
    var rawClass: Class;

    fn class() -> Class {
        assume Class::isNativeObject(SetObject::rawClass);
        SetObject::rawClass
    }
}

struct MapObject <: NativeObject;

impl MapObject {
    var rawClass: Class;

    fn class() -> Class {
        assume Class::isNativeObject(MapObject::rawClass);
        MapObject::rawClass
    }
}

struct BaseShape;

impl BaseShape {
    fn classOf(baseShape: BaseShape) -> Class;

    // #[reads(heap)]
    // fn protoOf(object: Object) -> TaggedProto;
    fn protoOf(baseShape: BaseShape) -> TaggedProto {
        (unsafe { BaseShape::protoOfUnchecked(heap, baseShape) })
    }

    unsafe fn protoOfUnchecked(heap: Heap, baseShape: BaseShape) -> TaggedProto;
}

struct Shape;

impl Shape {
    fn baseShapeOf(shape: Shape) -> BaseShape;

    fn classOf(shape: Shape) -> Class {
        let baseShape = Shape::baseShapeOf(shape);
        BaseShape::classOf(baseShape)
    }

    fn hasFixedSlot(shape: Shape, slot: UInt32) -> Bool;

    fn numFixedSlots(shape: Shape) -> UInt32;

    fn slotSpan(shape: Shape) -> UInt32;
}

struct Class;

impl Class {
    var rawFunctionClass: Class;
    var rawExtendedFunctionClass: Class;

    fn windowProxyClass() -> Class;

    fn isNativeObject(class: Class) -> Bool;
    fn isProxyObject(class: Class) -> Bool;

    fn isArgumentsObject(class: Class) -> Bool {
        class == MappedArgumentsObject::class() ||
            class == UnmappedArgumentsObject::class()
    }

    fn functionClass() -> Class {
        assume Class::isNativeObject(Class::rawFunctionClass);
        Class::rawFunctionClass
    }

    fn extendedFunctionClass() -> Class {
        assume Class::isNativeObject(Class::rawExtendedFunctionClass);
        Class::rawExtendedFunctionClass
    }
}

struct String;

impl String {
    fn hasIndexValue(string: String) -> Bool;

    fn getIndexValue(string: String) -> UInt32 {
        assert String::hasIndexValue(string);
        (unsafe { String::getIndexValueUnchecked(string) })
    }

    unsafe fn getIndexValueUnchecked(string: String) -> UInt32;
}

struct Symbol;

struct BigInt;

enum ProtoTag {
    Null,
    Lazy,
    Object,
}

struct TaggedProto;

impl TaggedProto {
    fn tag(proto: TaggedProto) -> ProtoTag;

    fn isNull(proto: TaggedProto) -> Bool {
        TaggedProto::tag(proto) == ProtoTag::Null
    }

    fn isLazy(proto: TaggedProto) -> Bool {
        TaggedProto::tag(proto) == ProtoTag::Lazy
    }

    fn isObject(proto: TaggedProto) -> Bool {
        TaggedProto::tag(proto) == ProtoTag::Object
    }

    fn toObject(proto: TaggedProto) -> Object {
        assert TaggedProto::isObject(proto);
        (unsafe { TaggedProto::toObjectUnchecked(proto) })
    }

    unsafe fn toObjectUnchecked(proto: TaggedProto) -> Object;
}
