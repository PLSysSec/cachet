// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./masm.cachet"

enum OperandLocationKind {
    Uninitialized,
    PayloadReg,
    ValueReg,
}

struct OperandLocation;

impl OperandLocation {
    fn kind(loc: OperandLocation) -> OperandLocationKind; 

    fn newUninitialized() -> OperandLocation {
        let loc = (unsafe { OperandLocation::newUninitializedUnchecked() });
        assume OperandLocation::kind(loc) == OperandLocationKind::Uninitialized;
        loc
    }

    unsafe fn newUninitializedUnchecked() -> OperandLocation;

    fn setValueReg(out loc: OperandLocation, valueReg: ValueReg) {
        (unsafe { OperandLocation::setValueRegUnchecked(out loc, valueReg) }); 
        assume OperandLocation::kind(loc) == OperandLocationKind::ValueReg;
        assume (unsafe { OperandLocation::getValueRegUnchecked(loc) } ) == valueReg;
    }

    unsafe fn setValueRegUnchecked(out loc: OperandLocation, valueReg: ValueReg);

    fn getValueReg(loc: OperandLocation) -> ValueReg {
        assert OperandLocation::kind(loc) == OperandLocationKind::ValueReg;
        let valueReg = (unsafe { OperandLocation::getValueRegUnchecked(loc) });
        valueReg
    }

    unsafe fn getValueRegUnchecked(loc: OperandLocation) -> ValueReg;

    fn setPayloadReg(out loc: OperandLocation, reg: Reg, type: ValueType) {
        (unsafe { OperandLocation::setPayloadRegUnchecked(out loc, reg, type) }); 
        assume OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        assume (unsafe { OperandLocation::getPayloadRegUnchecked(loc) } ) == reg;
        assume (unsafe { OperandLocation::getPayloadTypeUnchecked(loc) } ) == type;
    }

    unsafe fn setPayloadRegUnchecked(out loc: OperandLocation, reg: Reg, type: ValueType);

    fn getPayloadReg(loc: OperandLocation) -> Reg {
        assert OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        let reg = (unsafe { OperandLocation::getPayloadRegUnchecked(loc) });
        reg
    }

    unsafe fn getPayloadRegUnchecked(loc: OperandLocation) -> Reg;

    fn getPayloadType(loc: OperandLocation) -> ValueType {
        assert OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        let type = (unsafe { OperandLocation::getPayloadTypeUnchecked(loc) });
        type
    }

    unsafe fn getPayloadTypeUnchecked(loc: OperandLocation) -> ValueType;
}

struct OperandId;

// Corresponds to a ValOperandId
struct ValueId <: OperandId;

impl ValueId {
    fn toInt32Id(id: ValueId) -> Int32Id {
        unsafe { (id as OperandId) as Int32Id }
    }

    fn toObjectId(id: ValueId) -> ObjectId {
        unsafe { (id as OperandId) as ObjectId }
    }

    fn toNumberId(id: ValueId) -> NumberId {
        unsafe { id as NumberId }
    }
}

struct ObjectId <: OperandId;
struct Int32Id <: OperandId;
struct NumberId <: ValueId;
struct BooleanId <: OperandId;
struct StringId <: OperandId;
struct SymbolId <: OperandId;
struct BigIntId <: OperandId;

struct TypedId <: OperandId;

impl TypedId {
    fn type(typedId: TypedId) -> ValueType;

    fn isValueId(typedId: TypedId) -> Bool;

    fn fromValueId(valueId: ValueId, type: ValueType) -> TypedId {
        let typedId = (unsafe { TypedId::fromValueIdUnchecked(valueId, type) });
        assume TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == type;
        assume (unsafe { TypedId::toValueIdUnchecked(typedId) }) == valueId;
        assume (valueId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromValueIdUnchecked(valueId: ValueId, type: ValueType) -> TypedId; 

    fn toValueId(typedId: TypedId) -> ValueId {
        assert TypedId::isValueId(typedId);
        let type = TypedId::type(typedId);
        let valueId = (unsafe { TypedId::toValueIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromValueIdUnchecked(valueId, type) }) == typedId; 
        valueId
    }

    unsafe fn toValueIdUnchecked(typedId: TypedId) -> ValueId;

    fn fromObjectId(objectId: ObjectId) -> TypedId {
        let typedId = (unsafe { TypedId::fromObjectIdUnchecked(objectId) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::Object;
        assume (unsafe { TypedId::toObjectIdUnchecked(typedId) }) == objectId;
        assume (objectId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromObjectIdUnchecked(objectId: ObjectId) -> TypedId;

    fn toObjectId(typedId: TypedId) -> ObjectId {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::Object;
        let objectId = (unsafe { TypedId::toObjectIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromObjectIdUnchecked(objectId) }) == typedId;
        objectId
    }

    unsafe fn toObjectIdUnchecked(typedId: TypedId) -> ObjectId;

    fn fromInt32Id(int32Id: Int32Id) -> TypedId {
        let typedId = (unsafe { TypedId::fromInt32IdUnchecked(int32Id) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::Int32;
        assume (unsafe { TypedId::toInt32IdUnchecked(typedId) }) == int32Id;
        assume (int32Id as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromInt32IdUnchecked(int32Id: Int32Id) -> TypedId;

    fn toInt32Id(typedId: TypedId) -> Int32Id {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::Int32;
        let int32Id = (unsafe { TypedId::toInt32IdUnchecked(typedId) });
        assume (unsafe { TypedId::fromInt32IdUnchecked(int32Id) }) == typedId;
        int32Id
    }

    unsafe fn toInt32IdUnchecked(typedId: TypedId) -> Int32Id;

    fn fromBooleanId(booleanId: BooleanId) -> TypedId {
        let typedId = (unsafe { TypedId::fromBooleanIdUnchecked(booleanId) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::Bool;
        assume (unsafe { TypedId::toBooleanIdUnchecked(typedId) }) == booleanId;
        assume (booleanId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromBooleanIdUnchecked(booleanId: BooleanId) -> TypedId;

    fn toBooleanId(typedId: TypedId) -> BooleanId {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::Bool;
        let booleanId = (unsafe { TypedId::toBooleanIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromBooleanIdUnchecked(booleanId) }) == typedId;
        booleanId
    }

    unsafe fn toBooleanIdUnchecked(typedId: TypedId) -> BooleanId;

    fn fromStringId(stringId: StringId) -> TypedId {
        let typedId = (unsafe { TypedId::fromStringIdUnchecked(stringId) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::String;
        assume (unsafe { TypedId::toStringIdUnchecked(typedId) }) == stringId;
        assume (stringId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromStringIdUnchecked(stringId: StringId) -> TypedId;

    fn toStringId(typedId: TypedId) -> StringId {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::String;
        let stringId = (unsafe { TypedId::toStringIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromStringIdUnchecked(stringId) }) == typedId;
        stringId
    }

    unsafe fn toStringIdUnchecked(typedId: TypedId) -> StringId;

    fn fromSymbolId(symbolId: SymbolId) -> TypedId {
        let typedId = (unsafe { TypedId::fromSymbolIdUnchecked(symbolId) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::Symbol;
        assume (unsafe { TypedId::toSymbolIdUnchecked(typedId) }) == symbolId;
        assume (symbolId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromSymbolIdUnchecked(symbolId: SymbolId) -> TypedId;

    fn toSymbolId(typedId: TypedId) -> SymbolId {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::Symbol;
        let symbolId = (unsafe { TypedId::toSymbolIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromSymbolIdUnchecked(symbolId) }) == typedId;
        symbolId
    }

    unsafe fn toSymbolIdUnchecked(typedId: TypedId) -> SymbolId;

    fn fromBigIntId(bigIntId: BigIntId) -> TypedId {
        let typedId = (unsafe { TypedId::fromBigIntIdUnchecked(bigIntId) });
        assume !TypedId::isValueId(typedId);
        assume TypedId::type(typedId) == ValueType::BigInt;
        assume (unsafe { TypedId::toBigIntIdUnchecked(typedId) }) == bigIntId;
        assume (bigIntId as OperandId) == (typedId as OperandId);
        typedId
    }

    unsafe fn fromBigIntIdUnchecked(bigIntId: BigIntId) -> TypedId;

    fn toBigIntId(typedId: TypedId) -> BigIntId {
        assert !TypedId::isValueId(typedId);
        assert TypedId::type(typedId) == ValueType::BigInt;
        let bigIntId = (unsafe { TypedId::toBigIntIdUnchecked(typedId) });
        assume (unsafe { TypedId::fromBigIntIdUnchecked(bigIntId) }) == typedId;
        bigIntId
    }

    unsafe fn toBigIntIdUnchecked(typedId: TypedId) -> BigIntId;
}

struct ValueField;
struct ObjectField;
struct Int32Field;
struct ShapeField;
struct ClassField;

enum GuardClassKind {
    Array,
    PlainObject,
    ArrayBuffer,
    SharedArrayBuffer,
    DataView,
    MappedArguments,
    UnmappedArguments,
    WindowProxy,
    JSFunction,
    Set,
    Map,
}

ir CacheIR emits MASM {
    op GuardIsNumber(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestNumber(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsNullOrUndefined(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);

        label success: MASM;
        emit MASM::BranchTestNull(Condition::Equal, valueReg, success);
        emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);

        bind success;
    }

    op GuardIsNull(valueId: ValueId){
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsUndefined(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsNativeObject(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchIfNonNativeObj(objectReg, scratchReg, failure);

        CacheIR::releaseReg(scratchReg);
    }

    op GuardIsProxy(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObjectIsProxy(false, objectReg, scratchReg, failure);

        CacheIR::releaseReg(scratchReg);
    }

    op GuardInt32IsNonNegative(indexId: Int32Id) {
        let indexReg = CacheIR::useInt32Reg(indexId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::Branch32Imm(Condition::LessThan, indexReg, 0_i32, failure);
    }

    op IsObjectResult(inputId: ValueId) {
        let scratchReg = CacheIR::allocateReg();
        let valueReg = CacheIR::useValueReg(inputId);

        emit MASM::TestObjectSet(Condition::Equal, valueReg, scratchReg);
        emit MASM::TagValue(ValueType::Bool, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op GuardNonDoubleType(valueId: ValueId, type: ValueType) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        if type == ValueType::String {
            emit MASM::BranchTestString(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Symbol {
            emit MASM::BranchTestSymbol(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::BigInt {
            emit MASM::BranchTestBigInt(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Bool {
            emit MASM::BranchTestBoolean(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Undefined {
            emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Null {
            emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
        } else {
            assert false;
        }
    }

    op GuardClass(objId: ObjectId, kind: GuardClassKind) {
        let objReg = CacheIR::useObjectReg(objId);
        let scratchReg = CacheIR::allocateReg();
    
        CacheIR::addFailurePath(out label failure);

        if kind == GuardClassKind::JSFunction {
            if CacheIR::objectGuardNeedsSpectreMitigations(objId) {
                emit MASM::BranchTestObjIsFunction(Condition::NotEqual, objReg, scratchReg, objReg,
                                                    failure);
            } else {
                emit MASM::BranchTestObjIsFunctionNoSpectreMitigations(Condition::NotEqual, objReg,
                                                                        scratchReg, failure);
            }

            return;
        }

        let class = ArrayObject::class();

        if kind == GuardClassKind::Array {
            class = ArrayObject::class();
        } else if kind == GuardClassKind::PlainObject {
            class = PlainObject::class();
        } else if kind == GuardClassKind::ArrayBuffer {
            class = ArrayBufferObject::class();
        } else if kind == GuardClassKind::SharedArrayBuffer {
            class = SharedArrayBufferObject::class();
        } else if kind == GuardClassKind::DataView {
            class = DataViewObject::class();
        } else if kind == GuardClassKind::MappedArguments {
            class = MappedArgumentsObject::class();
        } else if kind == GuardClassKind::UnmappedArguments {
            class = UnmappedArgumentsObject::class();
        } else if kind == GuardClassKind::WindowProxy {
            class = Class::windowProxyClass();
        } else if kind == GuardClassKind::Set {
            class = SetObject::class();
        } else if kind == GuardClassKind::Map {
            class = MapObject::class();
        } else if kind == GuardClassKind::JSFunction {
            assert false; // this case was handled before
        }

        if CacheIR::objectGuardNeedsSpectreMitigations(objId) {
            emit MASM::BranchTestObjectClass(Condition::NotEqual, objReg, class, scratchReg, objReg,
                    failure);
        } else {
            emit MASM::BranchTestObjectClassNoSpectreMitigations(Condition::NotEqual, objReg, class,
                    scratchReg, failure);
        }

        CacheIR::releaseReg(scratchReg);
    }

    op GuardBooleanToInt32(valueId: ValueId, int32Id: Int32Id) {
        let int32Reg = CacheIR::defineInt32Reg(int32Id);
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);
        emit MASM::FallibleUnboxBoolean(valueReg, int32Reg, failure);
        emit MASM::CastBoolToInt32(int32Reg);
    }

    op GuardToObject(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField) {
      let objectReg = CacheIR::useObjectReg(objectId);
      let shape = CacheIR::readShapeField(shapeField);

      CacheIR::addFailurePath(out label failure);

      let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

      if needsSpectreMitigations {
        let scratchReg = CacheIR::allocateReg();
        emit MASM::BranchTestObjectShape(
            Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure
            );
        CacheIR::releaseReg(scratchReg);
      } else {
        emit MASM::BranchTestObjectShapeNoSpectreMitigations(
            Condition::NotEqual, objectReg, shape, failure
            );
      }
    }

    op GuardAnyClass(objectId: ObjectId, classField: ClassField) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        let class = CacheIR::readClassField(classField);

        CacheIR::addFailurePath(out label failure);

        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

        if needsSpectreMitigations {
            emit MASM::BranchTestObjectClass(
                Condition::NotEqual, objectReg, class, scratchReg, objectReg, failure
            );
        } else {
            emit MASM::BranchTestObjectClassNoSpectreMitigations(
                Condition::NotEqual, objectReg, class, scratchReg, failure
            );
        }

        CacheIR::releaseReg(scratchReg);
    }

    op GuardFixedSlotValue(objId: ObjectId,
                           offsetOffset: Int32Field,
                           valOffset: ValueField) {
        let obj = CacheIR::useObjectReg(objId);
        let offset = CacheIR::allocateReg();
        let scratchVal = CacheIR::allocateValueReg();

        CacheIR::addFailurePath(out label failure);

        CacheIR::emitLoadInt32StubField(offsetOffset, offset);
        CacheIR::emitLoadValueStubField(valOffset, scratchVal);

        let slotVal = BaseIndex::new(obj, offset, Scale::TimesOne, 0_u32);
        emit MASM::BranchTestValue(
            Condition::NotEqual, slotVal, scratchVal, failure
        );

        CacheIR::releaseReg(offset);
        CacheIR::releaseValueReg(scratchVal);
    }

    op GuardDynamicSlotValue(objId: ObjectId,
                           offsetOffset: Int32Field,
                           valOffset: ValueField) {
        let obj = CacheIR::useObjectReg(objId);
        let objSlots = CacheIR::allocateReg();
        let offset = CacheIR::allocateReg();
        let scratchVal = CacheIR::allocateValueReg();

        CacheIR::addFailurePath(out label failure);

        let objOffsetAddr = Address::new(obj, NativeObject::offsetOfSlots as Int32);
        emit MASM::LoadPtrAddress(objOffsetAddr, objSlots);

        CacheIR::emitLoadInt32StubField(offsetOffset, offset);
        CacheIR::emitLoadValueStubField(valOffset, scratchVal);

        let slotVal = BaseIndex::new(objSlots, offset, Scale::TimesOne, 0_u32);
        emit MASM::BranchTestValue(
            Condition::NotEqual, slotVal, scratchVal, failure
        );

        CacheIR::releaseReg(objSlots);
        CacheIR::releaseReg(offset);
        CacheIR::releaseValueReg(scratchVal);
    }

    op GuardToString(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestString(Condition::NotEqual, valueReg, failure);
    }

    op GuardToSymbol(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestSymbol(Condition::NotEqual, valueReg, failure);
    }

    op GuardToInt32(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestInt32(Condition::NotEqual, valueReg, failure);
    }

    op GuardToBoolean(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestBoolean(Condition::NotEqual, valueReg, failure);
    }

    op GuardToBigInt(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestBigInt(Condition::NotEqual, valueReg, failure);
    }

    op GuardNoDenseElements(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfElements as Int32), scratchReg
        );

        let initLength = Address::new(scratchReg, NativeObjectElements::offsetOfInitializedLength as Int32);

        emit MASM::Branch32AddressImm32(Condition::NotEqual, initLength, 0_i32, failure);

        CacheIR::releaseReg(scratchReg);
    }

    op BooleanToNumber(booleanId: BooleanId, numberId: NumberId) {
        let booleanReg = CacheIR::useBooleanReg(booleanId);
        let numberReg = CacheIR::defineNumberReg(numberId);

        emit MASM::CastBoolToInt32(booleanReg);
        emit MASM::TagValue(ValueType::Int32, booleanReg, numberReg);
    }

    op LoadObject(resultId: ObjectId, objField: ObjectField) {
        let resultReg = CacheIR::defineObjectReg(resultId);
        CacheIR::emitLoadObjectStubField(objField, resultReg);
    }

    op LoadProto(objectId: ObjectId, resultId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let resultReg = CacheIR::defineObjectReg(resultId);

        emit MASM::LoadObjectProto(objectReg, resultReg);
        emit MASM::UnboxObjectProto(resultReg, resultReg);
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slotOffset = CacheIR::readInt32Field(slotField);

        // Note: this uses TypedOrValueRegister but assuming here
        // that CacheIR::outputReg is always a Value
        emit MASM::LoadValueAddress(Address::new(objectReg, slotOffset), CacheIR::outputReg);
    }

    op LoadDynamicSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slotOffset = CacheIR::readInt32Field(slotField);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfSlots as Int32), scratchReg
        );
        // Note: this uses TypedOrValueRegister but assuming here
        // that CacheIR::outputReg is always a Value
        emit MASM::LoadValueAddress(
            Address::new(scratchReg, slotOffset), CacheIR::outputReg
        );

        CacheIR::releaseReg(scratchReg);
    }

    op LoadInt32ArrayLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfElements as Int32), scratchReg
        );
        emit MASM::Load32Address(
            Address::new(scratchReg, NativeObjectElements::offsetOfLength), scratchReg
        );

        emit MASM::BranchTest32(Condition::Signed, scratchReg, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op LoadArgumentsObjectLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let argObjLengthReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::LoadArgumentsObjectLength(objectReg, argObjLengthReg, failure);
        emit MASM::TagValue(ValueType::Int32, argObjLengthReg, CacheIR::outputReg);

        CacheIR::releaseReg(argObjLengthReg);
    }

    op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        let lhsReg = CacheIR::useValueReg(lhsId);
        let protoReg = CacheIR::useObjectReg(protoId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        label returnFalse: MASM;
        label returnTrue: MASM;
        label done: MASM;

        emit MASM::FallibleUnboxObject(lhsReg, scratchReg, failure);
        emit MASM::LoadObjectProto(scratchReg, scratchReg);

        label loopHead: MASM;
        bind loopHead;

        emit MASM::BranchTestNullProto(scratchReg, returnFalse);
        emit MASM::BranchTestLazyProto(scratchReg, failure);
        emit MASM::UnboxObjectProto(scratchReg, scratchReg);
        emit MASM::BranchObject(Condition::Equal, scratchReg, protoReg, returnTrue);

        emit MASM::LoadObjectProto(scratchReg, scratchReg);
        //emit MASM::StoreBool(true, protoReg); <-- uncomment to induce error
        emit MASM::Jump(loopHead);

        bind returnFalse;
        emit MASM::StoreBoolValue(false, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind returnTrue;
        emit MASM::StoreBoolValue(true, CacheIR::outputReg);

        bind done;

        CacheIR::releaseReg(scratchReg);
    }

    op LoadStringResult(stringId: StringId) {
        let stringReg = CacheIR::useStringReg(stringId);
        emit MASM::TagValue(ValueType::String, stringReg, CacheIR::outputReg);
    }

    op LoadSymbolResult(symbolId: SymbolId) {
        let symbolReg = CacheIR::useSymbolReg(symbolId);
        emit MASM::TagValue(ValueType::Symbol, symbolReg, CacheIR::outputReg);
    }

    op LoadInt32Result(int32Id: Int32Id) {
        let int32Reg = CacheIR::useInt32Reg(int32Id);
        emit MASM::TagValue(ValueType::Int32, int32Reg, CacheIR::outputReg);
    }

    op LoadBooleanResult(bool: Bool) {
        let value = Value::fromBool(bool);
        emit MASM::MoveValueImm(value, CacheIR::outputReg);
    }

    op LoadUndefinedResult() {
        let value = Value::getUndefined();
        emit MASM::MoveValueImm(value, CacheIR::outputReg);
    }

    op LoadBigIntResult(bigIntId: BigIntId) {
        let bigIntReg = CacheIR::useBigIntReg(bigIntId);
        emit MASM::TagValue(ValueType::BigInt, bigIntReg, CacheIR::outputReg);
    }

    op LoadDoubleResult(numberId: NumberId) {
        let numberReg = CacheIR::useNumberReg(numberId);

        // ifdef DEBUG
        // label ok: MASM;
        // emit MASM::BranchTestDouble(Condition::Equal, numberReg, ok);
        // emit MASM::BranchTestInt32(Condition::Equal, numberReg, ok);
        // emit MASM::AssumeUnreachable();
        // bind ok;
        // endif

        emit MASM::MoveValue(numberReg, CacheIR::outputReg);
        emit MASM::ConvertInt32ValueToDouble(CacheIR::outputReg);
    }

    op LoadInt32Constant(valField: Int32Field, resultId: Int32Id) {
        let resultReg = CacheIR::defineInt32Reg(resultId);

        CacheIR::emitLoadInt32StubField(valField, resultReg);
    }

    op LoadInt32TruthyResult(inputId: ValueId) {
        let valueReg = CacheIR::useValueReg(inputId);

        label ifFalse: MASM;
        label done: MASM;
        emit MASM::BranchTestInt32Truthy(false, valueReg, ifFalse);
        emit MASM::MoveValueImm(Value::fromBool(true), CacheIR::outputReg);
        emit MASM::Jump(done);

        bind ifFalse;
        emit MASM::MoveValueImm(Value::fromBool(false), CacheIR::outputReg);

        bind done;
    }

    op Int32AddResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::BranchAdd32(Condition::Overflow, lhsReg, scratchReg, failure);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32SubResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::BranchSub32(Condition::Overflow, rhsReg, scratchReg, failure);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32MulResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      let scratch2Reg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      label maybeNegZero: MASM;
      label done: MASM;

      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::BranchMul32(Condition::Overflow, rhsReg, scratchReg, failure);
      emit MASM::BranchTest32(Condition::Zero, scratchReg, scratchReg, maybeNegZero);
      emit MASM::Jump(done);

      bind maybeNegZero;
      emit MASM::Mov(lhsReg, scratch2Reg);
      emit MASM::Or32(rhsReg, scratch2Reg);
      emit MASM::BranchTest32(Condition::Signed, scratch2Reg, scratch2Reg, failure);

      bind done;
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32DivResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let remReg = CacheIR::allocateReg();
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        // prevent division by 0.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure);

        // prevent -2147483648 / -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure);
        bind notOverflow;

        // prevent negative 0.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, lhsReg, lhsReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, rhsReg, rhsReg, failure);
        bind notZero;

        emit MASM::Mov(lhsReg, scratchReg);
        // TODO(abhishekc-sharma): volatile registers
        emit MASM::FlexibleDivMod32(rhsReg, scratchReg, remReg);

        // A remainder implies a double result.
        emit MASM::BranchTest32(Condition::NonZero, remReg, remReg, failure);

        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(remReg);
        CacheIR::releaseReg(scratchReg);
    }

    op Int32ModResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        // x % 0 results in NaN.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure);

        // Prevent -2147483648 % -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure);
        bind notOverflow;

        emit MASM::Mov(lhsReg, scratchReg);
        // TODO(abhishekc-sharma): volatile registers
        emit MASM::FlexibleRemainder32(rhsReg, scratchReg);

        // Modulo takes the sign of the dividend; we can't return negative zero here.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, scratchReg, scratchReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, lhsReg, lhsReg, failure);
        bind notZero;

        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg); 
    }

    op Int32BitOrResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::Or32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32BitXorResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::Xor32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32BitAndResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::And32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32LeftShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::FlexibleLshift32(rhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32RightShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Mov(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32Arithmetic(rhsReg, scratchReg);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    // TODO(abhishekc-sharma): handle forceDouble.
    op Int32URightShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);
    
        emit MASM::Mov(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32(rhsReg, scratchReg);
        emit MASM::BranchTest32(Condition::Signed, scratchReg, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32NegationResult(inputId: Int32Id) {
      let inputReg = CacheIR::useInt32Reg(inputId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::BranchTest32Imm(Condition::Zero, inputReg, 0_i32, failure);
      emit MASM::Mov(inputReg, scratchReg);
      emit MASM::Neg32(scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32IncResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::BranchAdd32Imm(Condition::Overflow, 1_i32, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32DecResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::BranchAdd32Imm(Condition::Overflow, 1_i32, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32NotResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::Not32(scratchReg);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32MinMax(isMax: Bool, firstId: Int32Id, secondId: Int32Id, resultId: Int32Id) {
        let firstReg = CacheIR::useInt32Reg(firstId);
        let secondReg = CacheIR::useInt32Reg(secondId);
        let resultReg = CacheIR::defineInt32Reg(resultId);

        emit MASM::Mov(firstReg, resultReg);
        if isMax {
            emit MASM::Cmp32Move32(Condition::GreaterThan, secondReg,
                firstReg, secondReg, resultReg);
        } else {
            emit MASM::Cmp32Move32(Condition::LessThan, secondReg,
                firstReg, secondReg, resultReg);
        }
    }

    fn addFailurePath(out label failure: MASM);

    fn allocateReg() -> Reg;
    fn allocateKnownReg(reg: Reg);
    fn releaseReg(reg: Reg);

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn defineReg(typedId: TypedId) -> Reg;
    fn defineValueReg(valueId: ValueId) -> ValueReg;

    #[refined]
    fn defineObjectReg(id: ObjectId) -> Reg {
        let typedId = TypedId::fromObjectId(id);
        CacheIR::defineReg(typedId)
    }

    #[refined]
    fn defineInt32Reg(id: Int32Id) -> Reg {
        let typedId = TypedId::fromInt32Id(id);
        CacheIR::defineReg(typedId)
    }

    #[refined]
    fn defineNumberReg(id: NumberId) -> ValueReg {
        let valueId = id as ValueId;
        CacheIR::defineValueReg(valueId)
    }
        
    #[refined]
    fn defineBooleanReg(id: BooleanId) -> Reg {
        let typedId = TypedId::fromBooleanId(id);
        CacheIR::defineReg(typedId)
    }

    #[refined]
    fn defineStringReg(id: StringId) -> Reg {
        let typedId = TypedId::fromStringId(id);
        CacheIR::defineReg(typedId)
    }

    #[refined]
    fn defineSymbolReg(id: SymbolId) -> Reg {
        let typedId = TypedId::fromSymbolId(id);
        CacheIR::defineReg(typedId)
    }
    
    #[refined]
    fn defineBigIntReg(id: BigIntId) -> Reg {
        let typedId = TypedId::fromBigIntId(id);
        CacheIR::defineReg(typedId)
    }

    fn getOperandLocation(id: OperandId) -> OperandLocation;
    fn setOperandLocation(id: OperandId, loc: OperandLocation);

    #[refined]
    fn useReg(id: TypedId) emits MASM -> Reg {
        let operandId = id as OperandId; 
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        if locationKind == OperandLocationKind::PayloadReg {
            return OperandLocation::getPayloadReg(location);
        } else if locationKind == OperandLocationKind::ValueReg {
            let valueReg = OperandLocation::getValueReg(location);
            CacheIR::releaseValueReg(valueReg);
            let reg = ValueReg::scratchReg(valueReg);
            CacheIR::allocateKnownReg(reg);
            emit MASM::UnboxNonDouble(valueReg, reg, TypedId::type(id));
            OperandLocation::setPayloadReg(out location, reg, TypedId::type(id));
            CacheIR::setOperandLocation(operandId, location);
            return reg;
        } else {
            assert false;
        }
        return OperandLocation::getPayloadReg(location);
    }

    #[refined]
    fn useValueReg(valueId: ValueId) emits MASM -> ValueReg {
        let operandId = valueId as OperandId; 
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        if locationKind == OperandLocationKind::ValueReg {
            return OperandLocation::getValueReg(location);
        } else if locationKind == OperandLocationKind::PayloadReg {
            let reg = OperandLocation::getPayloadReg(location);
            let valTy = OperandLocation::getPayloadType(location);
            let valueReg = CacheIR::allocateValueReg();
            emit MASM::TagValue(valTy, reg, valueReg);
            OperandLocation::setValueReg(out location, valueReg);
            CacheIR::releaseReg(reg);
            return valueReg;
        } else {
            assert false;
        }
        return OperandLocation::getValueReg(location);
    }

    #[refined]
    fn useObjectReg(id: ObjectId) emits MASM -> Reg {
        let typedId = TypedId::fromObjectId(id);
        CacheIR::useReg(typedId)
    }

    #[refined]
    fn useInt32Reg(id: Int32Id) emits MASM -> Reg {
        let typedId = TypedId::fromInt32Id(id);
        CacheIR::useReg(typedId)
    }

    #[refined]
    fn useNumberReg(id: NumberId) emits MASM -> ValueReg {
        let valueId = id as ValueId;
        CacheIR::useValueReg(valueId)
    }

    #[refined]
    fn useBooleanReg(id: BooleanId) emits MASM -> Reg {
        let typedId = TypedId::fromBooleanId(id);
        CacheIR::useReg(typedId)
    }

    #[refined]
    fn useStringReg(id: StringId) emits MASM -> Reg {
        let typedId = TypedId::fromStringId(id);
        CacheIR::useReg(typedId)
    }

    #[refined]
    fn useSymbolReg(id: SymbolId) emits MASM -> Reg {
        let typedId = TypedId::fromSymbolId(id);
        CacheIR::useReg(typedId)
    }

    #[refined]
    fn useBigIntReg(id: BigIntId) emits MASM -> Reg {
        let typedId = TypedId::fromBigIntId(id);
        CacheIR::useReg(typedId)
    }

    var outputReg: ValueReg;

    #[refined]
    fn emitLoadInt32StubField(int32Field: Int32Field, dstReg: Reg) emits MASM {
       emit MASM::Move32Imm32(CacheIR::readInt32Field(int32Field), dstReg);
    }

    #[refined]
    fn emitLoadValueStubField(valueField: ValueField, dstReg: ValueReg) emits MASM {
       emit MASM::MoveValueImm(CacheIR::readValueField(valueField), dstReg);
    }

    #[refined]
    fn emitLoadObjectStubField(objectField: ObjectField, dstReg: Reg) emits MASM {
        emit MASM::MovePtrImmGCPtrObject(CacheIR::readObjectField(objectField), dstReg);
    }

    fn readValueField(valueField: ValueField) -> Value;
    fn readObjectField(objectField: ObjectField) -> Object;
    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;
    fn readClassField(classField: ClassField) -> Class;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;
}



//spec struct RegAllocState;

//impl CacheIR {
    //spec var mut regAllocState: RegAllocState;

    //spec var mut allocatedRegs: Set<Reg>;
    //spec var mut allocatedValueRegs: Set<ValueReg>;

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateReg() -> Reg;

    //refine fn allocateReg() -> Reg {
        //let reg = raw CacheIR::allocateReg();
        //assume !Set::contains(CacheIR::allocatedRegs, reg);
        //CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        //reg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseReg(reg: Reg);

    //refine fn releaseReg(reg: Reg) {
        //raw CacheIR::releaseReg(reg);
        //CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    //}

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateValueReg() -> ValueReg;

    //refine fn allocateValueReg() -> ValueReg {
        //let valueReg = raw CacheIR::allocateValueReg();
        //assume !Set::contains(CacheIR::allocatedValueRegs, valueReg);
        //CacheIR::allocatedValueRegs = Set::add(CacheIR::allocatedValueRegs, valueReg);
        //valueReg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseValueReg(valueReg: ValueReg);

    //refine fn releaseValueReg(valueReg: ValueReg) {
        //raw CacheIR::releaseValueReg(valueReg);
        //CacheIR::allocatedValueRegs = Set::remove(CacheIR::allocatedValueRegs, valueReg);
    //}
//}

// interpreter version:
//ir CacheIR {
    //op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        //CacheIR::getFailurePath(out label failure);

        //let lhs = CacheIR::getValue(lhsId);
        //let proto = CacheIR::getObject(protoId);

        //if !Value::isObject(lhs) {
            //goto failure;
        //}
        //let mut currentObject = Value::toObject(lhs);
        //let mut currentProto = Object::getProto(currentObject);

        //loop {
            //if Value::isNull(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //if Value::isMagic(currentProto) {
                //goto failure;
            //}

            //if !Value::isObject(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //currentObject = Value::toObject(currentProto);
            //if currentObject == proto {
                //CacheIR::setOutput(Value::fromBool(true));
                //return;
            //}

            //currentProto = Object::getProto(currentObject);
        //}
    //}
//}
