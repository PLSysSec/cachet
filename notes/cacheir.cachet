// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./masm.cachet"

struct ValueId;
struct ObjectId;
struct Int32Id;
struct NumberId;
struct BooleanId;
struct StringId;
struct SymbolId;
struct BigIntId;

struct ValueField;
struct Int32Field;
struct ShapeField;
struct ClassField;

ir CacheIR emits MASM {
    op GuardIsNumber(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestNumber(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsNullOrUndefined(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);

        label success: MASM;
        emit MASM::BranchTestNull(Condition::Equal, valueReg, success);
        emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);

        bind success;
    }

    op GuardIsNull(valueId: ValueId){
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsUndefined(valueId: ValueId) {
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);
    }

    op GuardIsNativeObject(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchIfNonNativeObj(objectReg, scratchReg, failure);

        CacheIR::releaseReg(scratchReg);
    }

    op GuardIsProxy(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObjectIsProxy(false, objectReg, scratchReg, failure);

        CacheIR::releaseReg(scratchReg);
    }

    op GuardInt32IsNonNegative(indexId: Int32Id) {
        let indexReg = CacheIR::useInt32Reg(indexId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::Branch32Imm(Condition::LessThan, indexReg, 0_i32, failure);
    }

    op GuardNonDoubleType(valueId: ValueId, type: ValueType) {
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);

        if type == ValueType::String {
            emit MASM::BranchTestString(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Symbol {
            emit MASM::BranchTestSymbol(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::BigInt {
            emit MASM::BranchTestBigInt(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Bool {
            emit MASM::BranchTestBoolean(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Undefined {
            emit MASM::BranchTestUndefined(Condition::NotEqual, valueReg, failure);
        } else if type == ValueType::Null {
            emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
        } else {
            assert false;
        }
    }

    op GuardBooleanToInt32(valueId: ValueId, int32Id: Int32Id) {
        let int32Reg = CacheIR::useInt32Reg(int32Id);
        let valueReg = CacheIR::useValueReg(valueId);

        CacheIR::addFailurePath(out label failure);
        emit MASM::FallibleUnboxBoolean(valueReg, int32Reg, failure);
        emit MASM::CastBoolToInt32(int32Reg);
    }

    op GuardToObject(valueId: ValueId, objectId: ObjectId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField) {
      let objectReg = CacheIR::useObjectReg(objectId);
      let shape = CacheIR::readShapeField(shapeField);

      CacheIR::addFailurePath(out label failure);

      let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

      if needsSpectreMitigations {
        let scratchReg = CacheIR::allocateReg();
        emit MASM::BranchTestObjectShape(
            Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure
            );
        CacheIR::releaseReg(scratchReg);
      } else {
        emit MASM::BranchTestObjectShapeNoSpectreMitigations(
            Condition::NotEqual, objectReg, shape, failure
            );
      }
    }

    op GuardAnyClass(objectId: ObjectId, classField: ClassField) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let scratchReg = CacheIR::allocateReg();
        let class = CacheIR::readClassField(classField);

        CacheIR::addFailurePath(out label failure);

        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

        if needsSpectreMitigations {
            emit MASM::BranchTestObjectClass(
                Condition::NotEqual, objectReg, class, scratchReg, objectReg, failure
            );
        } else {
            emit MASM::BranchTestObjectClassNoSpectreMitigations(
                Condition::NotEqual, objectReg, class, scratchReg, failure
            );
        }

        CacheIR::releaseReg(scratchReg);
    }

    op GuardToString(valueId: ValueId, stringId: StringId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let stringReg = CacheIR::useStringReg(stringId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestString(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxString(valueReg, stringReg);
    }

    op GuardToSymbol(valueId: ValueId, symbolId: SymbolId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let symbolReg = CacheIR::useSymbolReg(symbolId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestSymbol(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxSymbol(valueReg, symbolReg);
    }

    op GuardToInt32(valueId: ValueId, int32Id: Int32Id) {
        let valueReg = CacheIR::useValueReg(valueId);
        let int32Reg = CacheIR::useInt32Reg(int32Id);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestInt32(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxInt32(valueReg, int32Reg);
    }

    op GuardToBoolean(valueId: ValueId, booleanId: BooleanId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let booleanReg = CacheIR::useBooleanReg(booleanId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestBoolean(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxBoolean(valueReg, booleanReg);
    }

    op GuardToBigInt(valueId: ValueId, bigIntId: BigIntId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let bigIntReg = CacheIR::useBigIntReg(bigIntId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestBigInt(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxBigInt(valueReg, bigIntReg);
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }

    op LoadArgumentsObjectLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let argObjLengthReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::LoadArgumentsObjectLength(objectReg, argObjLengthReg, failure);
        emit MASM::TagValue(ValueType::Int32, argObjLengthReg, CacheIR::outputReg);

        CacheIR::releaseReg(argObjLengthReg);
    }

    op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        let lhsReg = CacheIR::useValueReg(lhsId);
        let protoReg = CacheIR::useObjectReg(protoId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        label loopHead: MASM;
        label returnFalse: MASM;
        label returnTrue: MASM;
        label done: MASM;

        emit MASM::BranchTestObject(Condition::NotEqual, lhsReg, returnFalse);
        emit MASM::UnboxObject(lhsReg, scratchReg);
        emit MASM::LoadObjectProto(scratchReg, lhsReg);

        bind loopHead;
        emit MASM::BranchTestNull(Condition::Equal, lhsReg, returnFalse);
        emit MASM::BranchTestMagic(Condition::Equal, lhsReg, failure);

        emit MASM::BranchTestObject(Condition::NotEqual, lhsReg, returnFalse);
        emit MASM::UnboxObject(lhsReg, scratchReg);
        emit MASM::BranchObject(Condition::Equal, scratchReg, protoReg, returnTrue);

        emit MASM::LoadObjectProto(scratchReg, lhsReg);
        //emit MASM::StoreBool(true, protoReg); <-- uncomment to induce error
        emit MASM::Jump(loopHead);

        bind returnFalse;
        emit MASM::StoreBoolValue(false, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind returnTrue;
        emit MASM::StoreBoolValue(true, CacheIR::outputReg);

        bind done;

        CacheIR::releaseReg(scratchReg);
    }

    op Int32AddResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::BranchAdd32(Condition::Overflow, lhsReg, scratchReg, failure);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32SubResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::BranchSub32(Condition::Overflow, rhsReg, scratchReg, failure);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32MulResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      let scratch2Reg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      label maybeNegZero: MASM;
      label done: MASM;

      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::BranchMul32(Condition::Overflow, rhsReg, scratchReg, failure);
      emit MASM::BranchTest32(Condition::Zero, scratchReg, scratchReg, maybeNegZero);
      emit MASM::Jump(done);

      bind maybeNegZero;
      emit MASM::Mov(lhsReg, scratch2Reg);
      emit MASM::Or32(rhsReg, scratch2Reg);
      emit MASM::BranchTest32(Condition::Signed, scratch2Reg, scratch2Reg, failure);

      bind done;
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32DivResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let remReg = CacheIR::allocateReg();
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        // prevent division by 0.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure);

        // prevent -2147483648 / -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure);
        bind notOverflow;

        // prevent negative 0.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, lhsReg, lhsReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, rhsReg, rhsReg, failure);
        bind notZero;

        emit MASM::Mov(lhsReg, scratchReg);
        // TODO(abhishekc-sharma): volatile registers
        emit MASM::FlexibleDivMod32(rhsReg, scratchReg, remReg);

        // A remainder implies a double result.
        emit MASM::BranchTest32(Condition::NonZero, remReg, remReg, failure);

        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(remReg);
        CacheIR::releaseReg(scratchReg);
    }

    op Int32ModResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        // x % 0 results in NaN.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure);

        // Prevent -2147483648 % -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure);
        bind notOverflow;

        emit MASM::Mov(lhsReg, scratchReg);
        // TODO(abhishekc-sharma): volatile registers
        emit MASM::FlexibleRemainder32(rhsReg, scratchReg);

        // Modulo takes the sign of the dividend; we can't return negative zero here.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, scratchReg, scratchReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, lhsReg, lhsReg, failure);
        bind notZero;

        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg); 
    }

    op Int32BitOrResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::Or32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32BitXorResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::Xor32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32BitAndResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(rhsReg, scratchReg);
      emit MASM::And32(lhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32LeftShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
      let lhsReg = CacheIR::useInt32Reg(lhsId);
      let rhsReg = CacheIR::useInt32Reg(rhsId);

      let scratchReg = CacheIR::allocateReg();
      emit MASM::Mov(lhsReg, scratchReg);
      emit MASM::FlexibleLshift32(rhsReg, scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32RightShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Mov(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32Arithmetic(rhsReg, scratchReg);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    // TODO(abhishekc-sharma): handle forceDouble.
    op Int32URightShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Reg(lhsId);
        let rhsReg = CacheIR::useInt32Reg(rhsId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);
    
        emit MASM::Mov(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32(rhsReg, scratchReg);
        emit MASM::BranchTest32(Condition::Signed, scratchReg, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32NegationResult(inputId: Int32Id) {
      let inputReg = CacheIR::useInt32Reg(inputId);
      let scratchReg = CacheIR::allocateReg();

      CacheIR::addFailurePath(out label failure);

      emit MASM::BranchTest32Imm(Condition::Zero, inputReg, 0_i32, failure);
      emit MASM::Mov(inputReg, scratchReg);
      emit MASM::Neg32(scratchReg);
      emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

      CacheIR::releaseReg(scratchReg);
    }

    op Int32IncResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::BranchAdd32Imm(Condition::Overflow, 1_i32, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32DecResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::BranchAdd32Imm(Condition::Overflow, 1_i32, scratchReg, failure);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32NotResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Reg(inputId);
        let scratchReg = CacheIR::allocateReg();

        emit MASM::Mov(inputReg, scratchReg);
        emit MASM::Not32(scratchReg);
        emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg);
    }

    op Int32MinMax(isMax: Bool, firstId: Int32Id, secondId: Int32Id, resultId: Int32Id) {
        let firstReg = CacheIR::useInt32Reg(firstId);
        let secondReg = CacheIR::useInt32Reg(secondId);
        let resultReg = CacheIR::useInt32Reg(resultId);

        emit MASM::Mov(firstReg, resultReg);
        if isMax {
            emit MASM::Cmp32Move32(Condition::GreaterThan, secondReg,
                firstReg, secondReg, resultReg);
        } else {
            emit MASM::Cmp32Move32(Condition::LessThan, secondReg,
                firstReg, secondReg, resultReg);
        }
    }

    fn addFailurePath(out label failure: MASM);

    fn allocateReg() -> Reg;
    fn releaseReg(reg: Reg);

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;
    fn useInt32Reg(int32Id: Int32Id) -> Reg;
    fn useBooleanReg(booleanId: BooleanId) -> Reg;
    fn useStringReg(stringId: StringId) -> Reg;
    fn useSymbolReg(symbolId: SymbolId) -> Reg;
    fn useBigIntReg(bigIntId: BigIntId) -> Reg;

    var outputReg: ValueReg;

    fn readValueField(valueField: ValueField) -> Value;
    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;
    fn readClassField(classField: ClassField) -> Class;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;
}

//spec struct RegAllocState;

//impl CacheIR {
    //spec var mut regAllocState: RegAllocState;

    //spec var mut allocatedRegs: Set<Reg>;
    //spec var mut allocatedValueRegs: Set<ValueReg>;

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateReg() -> Reg;

    //refine fn allocateReg() -> Reg {
        //let reg = raw CacheIR::allocateReg();
        //assume !Set::contains(CacheIR::allocatedRegs, reg);
        //CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        //reg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseReg(reg: Reg);

    //refine fn releaseReg(reg: Reg) {
        //raw CacheIR::releaseReg(reg);
        //CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    //}

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateValueReg() -> ValueReg;

    //refine fn allocateValueReg() -> ValueReg {
        //let valueReg = raw CacheIR::allocateValueReg();
        //assume !Set::contains(CacheIR::allocatedValueRegs, valueReg);
        //CacheIR::allocatedValueRegs = Set::add(CacheIR::allocatedValueRegs, valueReg);
        //valueReg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseValueReg(valueReg: ValueReg);

    //refine fn releaseValueReg(valueReg: ValueReg) {
        //raw CacheIR::releaseValueReg(valueReg);
        //CacheIR::allocatedValueRegs = Set::remove(CacheIR::allocatedValueRegs, valueReg);
    //}
//}

// interpreter version:
//ir CacheIR {
    //op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        //CacheIR::getFailurePath(out label failure);

        //let lhs = CacheIR::getValue(lhsId);
        //let proto = CacheIR::getObject(protoId);

        //if !Value::isObject(lhs) {
            //goto failure;
        //}
        //let mut currentObject = Value::toObject(lhs);
        //let mut currentProto = Object::getProto(currentObject);

        //loop {
            //if Value::isNull(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //if Value::isMagic(currentProto) {
                //goto failure;
            //}

            //if !Value::isObject(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //currentObject = Value::toObject(currentProto);
            //if currentObject == proto {
                //CacheIR::setOutput(Value::fromBool(true));
                //return;
            //}

            //currentProto = Object::getProto(currentObject);
        //}
    //}
//}
