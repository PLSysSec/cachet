// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(in value: Value) -> ValueType;

    // ...

    fn isInt32(in value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Int32
    }

    fn fromInt32(int32: Int32) -> Value {
        let value = (unsafe { Value::fromInt32Unchecked(int32) });
        assume Value::isInt32(value);
        assume (unsafe { Value::toInt32Unchecked(value) }) == int32;
        value
    }

    unsafe fn fromInt32Unchecked(int32: Int32) -> Value;

    fn toInt32(in value: Value) -> Int32 {
        assert Value::isInt32(value);
        let int32 = (unsafe { Value::toInt32Unchecked(value) });
        assume (unsafe { Value::fromInt32Unchecked(int32) }) == value;
        int32
    }

    unsafe fn toInt32Unchecked(in value: Value) -> Int32;

    fn isBool(in value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Bool
    }

    fn fromBool(bool: Bool) -> Value {
        let value = (unsafe { Value::fromBoolUnchecked(bool) });
        assume Value::isBool(value);
        assume (unsafe { Value::toBoolUnchecked(value) }) == bool;
        value
    }

    unsafe fn fromBoolUnchecked(bool: Bool) -> Value;

    fn toBool(in value: Value) -> Bool {
        assert Value::isBool(value);
        let bool = (unsafe { Value::toBoolUnchecked(value) });
        assume (unsafe { Value::fromBoolUnchecked(bool) }) == value;
        bool
    }

    unsafe fn toBoolUnchecked(in value: Value) -> Bool;

    fn isNull(in value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Null
    }

    fn isObject(in value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(in object: Object) -> Value {
        let value = (unsafe { Value::fromObjectUnchecked(object) });
        assume Value::isObject(value);
        assume (unsafe { Value::toObjectUnchecked(value) }) == object;
        value
    }

    unsafe fn fromObjectUnchecked(in object: Object) -> Value;

    fn toObject(in value: Value) -> Object {
        assert Value::isObject(value);
        let object = (unsafe { Value::toObjectUnchecked(value) });
        assume (unsafe { Value::fromObjectUnchecked(object) }) == value;
        object
    }

    unsafe fn toObjectUnchecked(in value: Value) -> Object;
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn shapeOf(object: Object) -> Shape;
    fn shapeOf(in object: Object) -> Shape {
        (unsafe { Object::shapeOfUnchecked(heap, object) })
    }

    unsafe fn shapeOfUnchecked(heap: Heap, in object: Object) -> Shape;

    fn toNativeObject(in object: Object) -> NativeObject {
        assert Class::isNativeObject(Shape::classOf(Object::shapeOf(object)));
        (unsafe { object as NativeObject })
    }

    fn toArgumentsObject(in object: Object) -> ArgumentsObject {
        assert Class::isArgumentsObject(Shape::classOf(Object::shapeOf(in object)));
        (unsafe { object as ArgumentsObject })
    }
  
    fn getFixedSlot(in object: Object, slot: Int32) -> Value {
        NativeObject::getFixedSlot(Object::toNativeObject(object), slot)
    }
}

struct NativeObject <: Object;

impl NativeObject {
    fn getFixedSlot(in nativeObject: NativeObject, slot: Int32) -> Value {
        assert Shape::hasFixedSlot(Object::shapeOf(nativeObject), slot);
        (unsafe { NativeObject::getFixedSlotUnchecked(heap, in nativeObject, slot) })
    }

    // #[reads(heap)]
    // unsafe fn getFixedSlotUnchecked(nativeObject: NativeObject, slot: Int32) -> Value;
    unsafe fn getFixedSlotUnchecked(heap: Heap, in nativeObject: NativeObject, slot: Int32)
        -> Value;
}

struct ArgumentsObject <: NativeObject;

impl ArgumentsObject {
    fn getInitialLength(obj: ArgumentsObject) -> Int32;
    fn hasOverriddenLength(obj: ArgumentsObject) -> Bool;
}

struct Shape;

impl Shape {
    fn classOf(in shape: Shape) -> Class;

    fn hasFixedSlot(in shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
    fn isNativeObject(class: Class) -> Bool;
    fn isArgumentsObject(class: Class) -> Bool;
}

struct Reg;
struct ValueReg;

enum Condition {
    Equal,
    NotEqual,
}

ir MASM {
    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal {
            if objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal {
            if objectHasShape {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                goto branch;
            }
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }

    op LoadArgumentsObjectLength(
        objectReg: Reg, outputReg: Reg, label failure: MASM
    ) {
        let obj = MASM::getObject(objectReg);
        let argObj = Object::toArgumentsObject(obj);
        if ArgumentsObject::hasOverriddenLength(argObj) {
            goto failure;
        }
        let length = ArgumentsObject::getInitialLength(argObj);
        MASM::setInt32(outputReg, length)
    }

    op TagValue(valTy: ValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == ValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        }
        else if valTy == ValueType::Object {
            let o = MASM::getObject(payload);
            let val = Value::fromObject(o);
            MASM::setValue(dest, val);
        }
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, in value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, in object: Object);
}

//impl MASM {
    //spec var mut regs: Map<Reg, Value>;
    //spec var mut valueRegs: Map<ValueReg, Value>;

    //fn getValue(valueReg: ValueReg) -> Value;

    //refine fn getValue(valueReg: ValueReg) -> Value {
        //Map::get(MASM::valueRegs, valueReg)
    //}

    //fn setValue(valueReg: ValueReg, value: Value);

    //refine fn setValue(valueReg: ValueReg, value: Value) {
        //MASM::valueRegs = Map::set(MASM::valueRegs, valueReg, value);
    //}

    //spec fn getUnboxedValue(reg: Reg) -> Value {
        //Map::get(MASM::regs, reg)
    //}

    //fn setUnboxedValue(reg: Reg, value: Value);

    //refine fn setUnboxedValue(reg: Reg, value: Value) {
        //MASM::regs = Map::set(MASM::regs, reg, value);
    //}

    //fn getInt32(reg: Reg) -> Int32;

    //refine fn getInt32(reg: Reg) -> Int32 {
        //Value::toInt32(MASM::getUnboxedValue(reg))
    //}

    //fn setInt32(reg: Reg, int32: Int32);

    //refine fn setInt32(reg: Reg, int32: Int32) {
        //MASM::setUnboxedValue(reg, Value::fromInt32(int32));
    //}

    //fn getObject(reg: Reg) -> Object;

    //refine fn getObject(reg: Reg) -> Object {
        //Value::toObject(MASM::getUnboxedValue(reg))
    //}

    //fn setObject(reg: Reg, object: Object);

    //refine fn setObject(reg: Reg, object: Object) {
        //MASM::setUnboxedValue(reg, Value::fromObject(object));
    //}
//}

struct ValueId;
struct ObjectId;

struct Int32Field;
struct ShapeField;

ir CacheIR emits MASM {
    op GuardIsNull(valueId: ValueId){
        let valueReg = CacheIR::useValueReg(valueId);
        CacheIR::addFailurePath(out label failure);
        emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
    }

    op GuardToObject(valueId: ValueId, objectId: ObjectId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let shape = CacheIR::readShapeField(shapeField);

        CacheIR::addFailurePath(out label failure);

        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

        if needsSpectreMitigations {
            let scratchReg = CacheIR::allocateReg();
            emit MASM::BranchTestObjectShape(
                Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure
            );
            CacheIR::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjectShapeNoSpectreMitigations(
                Condition::NotEqual, objectReg, shape, failure
            );
        }
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }

    op LoadArgumentsObjectLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let argObjLengthReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        emit MASM::LoadArgumentsObjectLength(objectReg, argObjLengthReg, failure);
        emit MASM::TagValue(ValueType::Int32, argObjLengthReg, CacheIR::outputReg);

        CacheIR::releaseReg(argObjLengthReg);
    }

    fn addFailurePath(out label failure: MASM);

    fn allocateReg() -> Reg;
    fn releaseReg(reg: Reg);

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;
}

//spec struct RegAllocState;

//impl CacheIR {
    //spec var mut regAllocState: RegAllocState;

    //spec var mut allocatedRegs: Set<Reg>;
    //spec var mut allocatedValueRegs: Set<ValueReg>;

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateReg() -> Reg;

    //refine fn allocateReg() -> Reg {
        //let reg = raw CacheIR::allocateReg();
        //assume !Set::contains(CacheIR::allocatedRegs, reg);
        //CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        //reg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseReg(reg: Reg);

    //refine fn releaseReg(reg: Reg) {
        //raw CacheIR::releaseReg(reg);
        //CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    //}

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateValueReg() -> ValueReg;

    //refine fn allocateValueReg() -> ValueReg {
        //let valueReg = raw CacheIR::allocateValueReg();
        //assume !Set::contains(CacheIR::allocatedValueRegs, valueReg);
        //CacheIR::allocatedValueRegs = Set::add(CacheIR::allocatedValueRegs, valueReg);
        //valueReg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseValueReg(valueReg: ValueReg);

    //refine fn releaseValueReg(valueReg: ValueReg) {
        //raw CacheIR::releaseValueReg(valueReg);
        //CacheIR::allocatedValueRegs = Set::remove(CacheIR::allocatedValueRegs, valueReg);
    //}
//}

ir CacheStub emits CacheIR {
    op GetProp(
        valueId: ValueId,
        objectId: ObjectId,
        shapeField: ShapeField,
        slotField: Int32Field,
    ) {
        assume CacheIR::useValueReg(valueId) == CacheIR::allocateValueReg();
        assume CacheIR::useObjectReg(objectId) == CacheIR::allocateReg();

        let mut shape = CacheIR::readShapeField(shapeField);

        assume Class::isNativeObject(Shape::classOf(shape));

        assume Shape::hasFixedSlot(shape, 0_i32);
        assume Shape::hasFixedSlot(shape, 1_i32);
        assume Shape::hasFixedSlot(shape, 2_i32);

        let slot = CacheIR::readInt32Field(slotField);
        assume slot == 1_i32;

        emit CacheIR::GuardToObject(valueId, objectId);
        emit CacheIR::GuardShape(objectId, shapeField);
        emit CacheIR::LoadFixedSlotResult(objectId, slotField);
    }
}
