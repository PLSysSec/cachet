// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;

    /* ... */

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = unsafe { Value::fromObjectUnchecked(object) };
        assume Value::isObject(value);
        assume unsafe { Value::toObjectUnchecked(value) } == object;
        value
    }
    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = unsafe { Value::toObjectUnchecked(value) };
        assume unsafe { Value::fromObjectUnchecked(object) } == value;
        object
    }
    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn shapeOf(object: Object) -> Shape;
    fn shapeOf(object: Object) -> Shape {
        unsafe { Object::shapeOfUnchecked(heap, object) }
    }
    unsafe fn shapeOfUnchecked(heap: Heap, object: Object) -> Shape;

    fn toNativeObject(object: Object) -> NativeObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isNativeObject(class);
        unsafe { object as NativeObject }
    }
  
    fn getFixedSlot(object: Object, slot: Int32) -> Value {
        let nativeObject = Object::toNativeObject(object);
        NativeObject::getFixedSlot(nativeObject, slot)
    }
}

struct NativeObject <: Object;

impl NativeObject {
    // #[reads(heap)]
    // fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value;
    fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert Shape::hasFixedSlot(shape, slot);
        unsafe { NativeObject::getFixedSlotUnchecked(heap, nativeObject, slot) }
    }
    unsafe fn getFixedSlotUnchecked(heap: Heap, nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
    fn classOf(shape: Shape) -> Class;

    fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
    fn isNativeObject(class: Class) -> Bool;
}

// #[cfg(spec)]
// type ValueReg = Reg;
// #[cfg(impl)]
struct ValueReg;

struct Reg;

ir MASM {
    // #[cfg(spec)]
    // var mut regs: Map<Reg, Value>;

    // #[cfg(spec)]
    // fn getValue(valueReg: ValueReg) -> Value {
        // Map::get(MASM::regs, valueReg)
    // }

    // #[cfg(impl)]
    fn getValue(valueReg: ValueReg) -> Value;

    // #[cfg(spec)]
    // fn setValue(valueReg: ValueReg, value: Value) {
        // MASM::regs = Map::set(MASM::regs, valueReg, value);
    // }

    // #[cfg(impl)]
    fn setValue(valueReg: ValueReg, value: Value);

    // #[cfg(spec)]
    // fn getObject(reg: Reg) -> Object {
        // Value::toObject(MASM::getValue(reg))
    // }

    // #[cfg(impl)]
    fn getObject(reg: Reg) -> Object;

    // #[cfg(spec)]
    // fn setObject(reg: Reg, object: Object) {
        // MASM::setValue(reg, Value::fromObject(object));
    // }

    // #[cfg(impl)]
    fn setObject(reg: Reg, object: Object);

    op BranchTestNotObject(valueReg: ValueReg, label branch) {
        let value = MASM::getValue(valueReg);
        if !Value::isObject(value) {
            goto branch;
        }
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op BranchTestNotObjectShape(objectReg: Reg, shape: Shape, label branch) {
        let object = MASM::getObject(objectReg);
        if Object::shapeOf(object) != shape {
            goto branch;
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }
}

struct ValueId;
struct ObjectId;

struct Int32Field;
struct ShapeField;

ir CacheIR emits MASM {
    // #[cfg(spec)]
    // fn allocateValueReg() -> ValueReg {
        // CacheIR::allocateReg()
    // }

    // #[cfg(impl)]
    fn allocateValueReg() -> ValueReg;

    // #[cfg(spec)]
    // fn releaseValueReg(valueReg: ValueReg) {
        // CacheIR::releaseReg(valueReg);
    // }

    // #[cfg(impl)]
    fn releaseValueReg(valueReg: ValueReg);

    // #[cfg(spec)]
    // var mut allocatedRegs: Set<Reg>;

    // #[cfg(spec)]
    // fn allocateReg() -> Reg {
        // let reg = unsafe { CacheIR::allocateRegUnchecked(CacheIR::allocatedRegs) };
        // assume !Set::contains(CacheIR::allocatedRegs, reg);
        // CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        // reg
    // }
    // #[cfg(spec)]
    // unsafe fn allocateRegUnchecked(allocatedRegs: Set<Reg>) -> Reg;

    // #[cfg(impl)]
    fn allocateReg() -> Reg;

    // #[cfg(spec)]
    // fn releaseReg(reg: Reg) {
        // CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    // }

    // #[cfg(impl)]
    fn releaseReg(reg: Reg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;

    op GuardToObject(valueId: ValueId, objectId: ObjectId, label failure) {
        //object = Value::toObject(value);
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);
        emit MASM::BranchTestNotObject(valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField, label failure) {
        //guard Object::shapeOf(object) == shape;
        let objectReg = CacheIR::useObjectReg(objectId);
        let shape = CacheIR::readShapeField(shapeField);
        emit MASM::BranchTestNotObjectShape(objectReg, shape, failure);
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        //fallible { Object::getFixedSlot(object, slot) }
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }
}
