// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

var zero: Int32;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;

    /* ... */

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = unsafe { Value::fromObjectUnchecked(object) };
        assume Value::isObject(value);
        assume unsafe { Value::toObjectUnchecked(value) } == object;
        value
    }
    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = unsafe { Value::toObjectUnchecked(value) };
        assume unsafe { Value::fromObjectUnchecked(object) } == value;
        object
    }
    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn shapeOf(object: Object) -> Shape;
    fn shapeOf(object: Object) -> Shape {
        unsafe { Object::shapeOfUnchecked(heap, object) }
    }
    unsafe fn shapeOfUnchecked(heap: Heap, object: Object) -> Shape;

    fn toNativeObject(object: Object) -> NativeObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isNativeObject(class);
        unsafe { object as NativeObject }
    }
  
    fn getFixedSlot(object: Object, slot: Int32) -> Value {
        let nativeObject = Object::toNativeObject(object);
        NativeObject::getFixedSlot(nativeObject, slot)
    }
}

struct NativeObject <: Object;

impl NativeObject {
    // #[reads(heap)]
    // fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value;
    fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert Shape::hasFixedSlot(shape, slot);
        unsafe { NativeObject::getFixedSlotUnchecked(heap, nativeObject, slot) }
    }
    unsafe fn getFixedSlotUnchecked(heap: Heap, nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
    fn classOf(shape: Shape) -> Class;

    fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
    fn isNativeObject(class: Class) -> Bool;
}

// #[cfg(spec)]
// type ValueReg = Reg;
// #[cfg(impl)]
struct ValueReg;

struct Reg;

enum Condition {
    Equal,
    NotEqual,
}

ir MASM {
    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, zero);

        if condition == Condition::Equal {
            if objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal {
            if !objectHasShape {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if objectHasShape {
                goto branch;
            }
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }

    // #[cfg(spec)]
    // var mut regs: Map<Reg, Value>;

    // #[cfg(spec)]
    // fn getValue(valueReg: ValueReg) -> Value {
        // Map::get(MASM::regs, valueReg)
    // }

    // #[cfg(impl)]
    fn getValue(valueReg: ValueReg) -> Value;

    // #[cfg(spec)]
    // fn setValue(valueReg: ValueReg, value: Value) {
        // MASM::regs = Map::set(MASM::regs, valueReg, value);
    // }

    // #[cfg(impl)]
    fn setValue(valueReg: ValueReg, value: Value);

    // #[cfg(spec)]
    // fn getInt32(reg: Reg) -> Int32 {
        // Value::toInt32(MASM::getValue(reg))
    // }

    // #[cfg(impl)]
    fn getInt32(reg: Reg) -> Int32;

    // #[cfg(spec)]
    // fn setInt32(reg: Reg, int32: Int32) {
        // MASM::setValue(reg, Value::fromInt32(int32));
    // }

    // #[cfg(impl)]
    fn setInt32(reg: Reg, int32: Int32);

    // #[cfg(spec)]
    // fn getObject(reg: Reg) -> Object {
        // Value::toObject(MASM::getValue(reg))
    // }

    // #[cfg(impl)]
    fn getObject(reg: Reg) -> Object;

    // #[cfg(spec)]
    // fn setObject(reg: Reg, object: Object) {
        // MASM::setValue(reg, Value::fromObject(object));
    // }

    // #[cfg(impl)]
    fn setObject(reg: Reg, object: Object);
}

struct ValueId;
struct ObjectId;

struct Int32Field;
struct ShapeField;

ir CacheIR emits MASM {
    op GuardToObject(valueId: ValueId, label failure) {
        let valueReg = CacheIR::useValueReg(valueId);
        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField, label failure) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let shape = CacheIR::readShapeField(shapeField);

        if CacheIR::objectGuardNeedsSpectreMitigations(objectId) {
            let scratchReg = CacheIR::allocateReg();
            emit MASM::BranchTestObjectShape(
                Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure
            );
            CacheIR::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjectShapeNoSpectreMitigations(
                Condition::NotEqual, objectReg, shape, failure
            );
        }
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }

    // #[cfg(spec)]
    // fn allocateValueReg() -> ValueReg {
        // CacheIR::allocateReg()
    // }

    // #[cfg(impl)]
    fn allocateValueReg() -> ValueReg;

    // #[cfg(spec)]
    // fn releaseValueReg(valueReg: ValueReg) {
        // CacheIR::releaseReg(valueReg);
    // }

    // #[cfg(impl)]
    fn releaseValueReg(valueReg: ValueReg);

    // #[cfg(spec)]
    // var mut allocatedRegs: Set<Reg>;

    // #[cfg(spec)]
    // fn allocateReg() -> Reg {
        // let reg = unsafe { CacheIR::allocateRegUnchecked(CacheIR::allocatedRegs) };
        // assume !Set::contains(CacheIR::allocatedRegs, reg);
        // CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        // reg
    // }
    // #[cfg(spec)]
    // unsafe fn allocateRegUnchecked(allocatedRegs: Set<Reg>) -> Reg;

    // #[cfg(impl)]
    fn allocateReg() -> Reg;

    // #[cfg(spec)]
    // fn releaseReg(reg: Reg) {
        // CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    // }

    // #[cfg(impl)]
    fn releaseReg(reg: Reg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;
}
