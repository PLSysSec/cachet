// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./js.cachet"

struct Reg;

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

struct FloatReg;

struct LiveRegisterSet;

impl LiveRegisterSet {
    fn addGeneralReg(lrs: LiveRegisterSet, reg: Reg);
    fn addFloatReg(lrs: LiveRegisterSet, floatReg: FloatReg);
}

enum Condition {
    Equal,
    NotEqual,
    Overflow,
    Zero,
    NonZero,
    Signed,
    NotSigned,
}

ir MASM {
    op Mov(srcReg: Reg, dstReg: Reg) {
      MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op MoveValue(srcReg: ValueReg, dstReg: ValueReg) {
        MASM::setValue(dstReg, MASM::getValue(srcReg));
    }

    op StoreBool(bool: Bool, reg: Reg) {
        MASM::setBool(reg, bool);
    }

    op StoreBoolValue(bool: Bool, valueReg: ValueReg) {
        MASM::setValue(valueReg, Value::fromBool(bool));
    }

    op Jump(label target: MASM) {
      goto target;
    }

    op TagValue(valTy: ValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == ValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        } else if valTy == ValueType::String {
            let s = MASM::getString(payload);
            let val = Value::fromString(s);
            MASM::setValue(dest, val);
        } else {
            assert false;
        }
    }

    op BoxDouble(floatReg: FloatReg, dstReg: ValueReg, srcReg: FloatReg) {
        let double = MASM::getDouble(floatReg);
        let val = Value::fromDouble(double);
        MASM::setValue(dstReg, val);
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
      let value = MASM::getValue(valueReg);
      MASM::setInt32(int32Reg, Value::toInt32(value)); 
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op FallibleUnboxBoolean(valueReg: ValueReg, boolReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if !valueIsBool {
            goto failure;
        }

        let bool = Value::toBool(value);
        MASM::setBool(boolReg, bool);
    }

    op UnboxString(valueReg: ValueReg, stringReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setString(stringReg, Value::toString(value));
    }

    // NOTE: This Op needs to be implemented as a Phantom Op on the
    // C++ side since Firefox implicitly reinterprets booleans
    // as int32 within registers.
    op CastBoolToInt32(int32Reg: Reg) {
        let bool = MASM::getBool(int32Reg);
        if bool {
            MASM::setInt32(int32Reg, 1_i32);
        } else {
            MASM::setInt32(int32Reg, 0_i32);
        }
    }

    op ConvertInt32ValueToDouble(valueReg: ValueReg) {
        let value = MASM::getValue(valueReg);

        if !Value::isInt32(value) {
            return;
        }

        let int32 = Value::toInt32(value);
        let double = int32 as Double;
        MASM::setValue(valueReg, Value::fromDouble(double));
    }

    op EnsureDouble(valueReg: ValueReg, floatReg: FloatReg, label failure: MASM) {
        let value = MASM::getValue(valueReg);

        if Value::isDouble(value) {
            let double = Value::toDouble(value);
            MASM::setDouble(floatReg, double);
        } else if Value::isInt32(value) {
            let int32 = Value::toInt32(value);
            let double = int32 as Double;
            MASM::setDouble(floatReg, double);
        } else {
            goto failure;
        }
    }

    op GuardStringToInt32(
        strReg: Reg, outputReg: Reg, scratchReg: Reg,
        volatileRegs: LiveRegisterSet, label failure: MASM
    ) {
        let str = MASM::getString(strReg);

        if String::hasIndexValue(str) {
            let index = String::getIndexValue(str);
            MASM::setInt32(outputReg, index);
        } else {
            if !VMFunction::GetInt32FromStringPureSuccess(str) {
                goto failure;
            }

            let output = VMFunction::GetInt32FromStringPure(str);
            MASM::setInt32(outputReg, output);
        }
    }

    op BranchTestNumber(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsNumber = Value::isInt32(value) || Value::isDouble(value);

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestDouble(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsDouble = Value::isDouble(value);

        if condition == Condition::Equal && valueIsDouble {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsDouble {
            goto branch;
        }
    }

    op BranchObject(
        condition: Condition,
        lhsReg: Reg,
        rhsReg: Reg,
        label branch: MASM,
    ) {
        let lhs = MASM::getObject(lhsReg);
        let rhs = MASM::getObject(rhsReg);
        let isEqual = lhs == rhs;

        if condition == Condition::Equal {
            if isEqual {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !isEqual {
                goto branch;
            }
        }
    }

    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
      let value = MASM::getValue(valueReg);
      let valueIsInt32 = Value::isInt32(value);

      if condition == Condition::Equal {
        if valueIsInt32 {
          goto branch;
        }
      } else if condition == Condition::NotEqual {
        if !valueIsInt32 {
          goto branch;
        }
      } else {
        assert false;
      }
    }

    op BranchTestString(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsString = Value::isString(value);

        if condition == Condition::Equal && valueIsString {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsString {
            goto branch;
        }
    }

    op BranchTest32(condition: Condition, src1Reg: Reg, src2Reg: Reg, label branch: MASM) {
      let src1Int32 = MASM::getInt32(src1Reg);
      let src2Int32 = MASM::getInt32(src2Reg);

      let result = src1Int32 & src2Int32;

      assert condition != Condition::Equal;
      assert condition != Condition::NotEqual;
      assert condition != Condition::Overflow;

      if condition == Condition::Zero {
        if result == 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NonZero {
        if result != 0_i32 {
          goto branch;
        }
      } else if condition == Condition::Signed {
        if result < 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NotSigned {
        if result > 0_i32 {
          goto branch;
        }
      }
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
      let value = MASM::getValue(valueReg);
      let valueIsObject = Value::isObject(value);

      if condition == Condition::Equal {
        if valueIsObject {
          goto branch;
        }
      }

      if condition == Condition::NotEqual {
        if !valueIsObject {
          goto branch;
        }
      }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op BranchTestMagic(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsMagic = Value::isMagic(value);

        if condition == Condition::Equal {
            if valueIsMagic {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsMagic {
                goto branch;
            }
        }
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal {
            if objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal {
            if objectHasShape {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                goto branch;
            }
        }
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 + rhsInt32;
      
      assert condition == Condition::Overflow;
      if lhsInt32 > 0_i32 {
        if rhsInt32 > 0_i32 {
          if result < 0_i32 {
            goto branch;
          }
        }
      }

      if lhsInt32 < 0_i32 {
        if rhsInt32 < 0_i32 {
          if result > 0_i32 {
            goto branch;
          }
        }
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchSub32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 - rhsInt32;

      assert condition == Condition::Overflow;

      let rhsInt32Neg = -rhsInt32;
      let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

      if rhsInt32 == minInt32 {
        if lhsInt32 >= 0_i32 {
          goto branch;
        }
      } else {
        if lhsInt32 > 0_i32 {
          if rhsInt32 < 0_i32 {
            if result < 0_i32 {
              goto branch;
            }
          }
        }
      }

      if lhsInt32 < 0_i32 {
        if rhsInt32 > 0_i32 {
          if result > 0_i32 {
            goto branch;
          }
        }
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchMul32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 * rhsInt32;

      assert condition == Condition::Overflow;

      let resultWide = (lhsInt32 as Int64) * (rhsInt32 as Int64);
      if (result as Int64) != resultWide {
        goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op Or32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 | rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op Xor32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 ^ rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op And32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 & rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op FlexibleLshift32(shiftReg: Reg, srcDestReg: Reg) {
      let shiftInt32 = MASM::getInt32(shiftReg);
      let srcInt32 = MASM::getInt32(srcDestReg);

      let result = srcInt32 << shiftInt32;

      MASM::setInt32(srcDestReg, result);
    }

    op NegateDouble(floatReg: FloatReg) {
        let double = MASM::getDouble(floatReg);
        let result = -double;
        MASM::setDouble(floatReg, result);
    }

    op AddDouble(srcReg: FloatReg, dstReg: FloatReg) {
        let lhs = MASM::getDouble(dstReg);
        let rhs = MASM::getDouble(srcReg);
        let result = lhs + rhs;
        MASM::setDouble(dstReg, result);
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }

    op LoadArgumentsObjectLength(
        objectReg: Reg, outputReg: Reg, label failure: MASM
    ) {
        let obj = MASM::getObject(objectReg);
        let argObj = Object::toArgumentsObject(obj);
        if ArgumentsObject::hasOverriddenLength(argObj) {
            goto failure;
        }
        let length = ArgumentsObject::getInitialLength(argObj);
        MASM::setInt32(outputReg, length)
    }

    op LoadObjectProto(objectReg: Reg, protoReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(protoReg, Object::protoOf(object));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getDouble(floatReg: FloatReg) -> Double;
    fn setDouble(floatReg: FloatReg, double: Double);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);

    fn getBool(reg: Reg) -> Bool;
    fn setBool(reg: Reg, bool: Bool);

    fn getString(reg: Reg) -> String;
    fn setString(reg: Reg, string: String);

    fn volatileLiveRegisterSet() -> LiveRegisterSet;
    fn emptyLiveRegisterSet() -> LiveRegisterSet;
}

//impl MASM {
    //spec var mut regs: Map<Reg, Value>;
    //spec var mut valueRegs: Map<ValueReg, Value>;

    //fn getValue(valueReg: ValueReg) -> Value;

    //refine fn getValue(valueReg: ValueReg) -> Value {
        //Map::get(MASM::valueRegs, valueReg)
    //}

    //fn setValue(valueReg: ValueReg, value: Value);

    //refine fn setValue(valueReg: ValueReg, value: Value) {
        //MASM::valueRegs = Map::set(MASM::valueRegs, valueReg, value);
    //}

    //spec fn getUnboxedValue(reg: Reg) -> Value {
        //Map::get(MASM::regs, reg)
    //}

    //fn setUnboxedValue(reg: Reg, value: Value);

    //refine fn setUnboxedValue(reg: Reg, value: Value) {
        //MASM::regs = Map::set(MASM::regs, reg, value);
    //}

    //fn getInt32(reg: Reg) -> Int32;

    //refine fn getInt32(reg: Reg) -> Int32 {
        //Value::toInt32(MASM::getUnboxedValue(reg))
    //}

    //fn setInt32(reg: Reg, int32: Int32);

    //refine fn setInt32(reg: Reg, int32: Int32) {
        //MASM::setUnboxedValue(reg, Value::fromInt32(int32));
    //}

    //fn getObject(reg: Reg) -> Object;

    //refine fn getObject(reg: Reg) -> Object {
        //Value::toObject(MASM::getUnboxedValue(reg))
    //}

    //fn setObject(reg: Reg, object: Object);

    //refine fn setObject(reg: Reg, object: Object) {
        //MASM::setUnboxedValue(reg, Value::fromObject(object));
    //}
//}
