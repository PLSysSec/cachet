// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./js.cachet"

enum Reg {
    Rax,
    Rcx,
    Rdx,
    Rbx,
    Rsp,
    Rbp,
    Rsi,
    Rdi,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
}

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

impl ValueReg {
    fn scratchReg(valueReg: ValueReg) -> Reg;
    fn payloadOrValueReg(valueReg: ValueReg) -> Reg;
}

struct TypedOrValueReg;

enum PhyFloatReg {
    Xmm0,
    Xmm1,
    Xmm2,
    Xmm3,
    Xmm4,
    Xmm5,
    Xmm6,
    Xmm7,
    Xmm8,
    Xmm9,
    Xmm10,
    Xmm11,
    Xmm12,
    Xmm13,
    Xmm14,
    Xmm15,
}

enum FloatContentType {
    Single,
    Double,
    Simd128,
}

struct FloatReg {
   reg: PhyFloatReg,
   type: FloatContentType,
}

impl FloatReg {
    fn new(reg: PhyFloatReg, type: FloatContentType) -> FloatReg {
        let floatReg = (unsafe { FloatReg::newUnchecked(reg, type) });
        assume floatReg.reg == reg;
        assume floatReg.type == type;
        floatReg
    }

    fn newDouble(reg: PhyFloatReg) -> FloatReg {
        FloatReg::new(reg, FloatContentType::Double)
    }

    unsafe fn newUnchecked(reg: PhyFloatReg, type: FloatContentType) -> FloatReg;
}

struct AnyReg;

impl AnyReg {
    fn isFloat(anyReg: AnyReg) -> Bool;

    fn fromReg(reg: Reg) -> AnyReg {
       let anyReg = (unsafe { AnyReg::fromRegUnchecked(reg) });
       assume !AnyReg::isFloat(anyReg);
       assume (unsafe { AnyReg::toRegUnchecked(anyReg) }) == reg;
       anyReg
    }

    unsafe fn fromRegUnchecked(reg: Reg) -> AnyReg;

    fn toReg(anyReg: AnyReg) -> Reg {
        assert !AnyReg::isFloat(anyReg);
        let reg = (unsafe { AnyReg::toRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromRegUnchecked(reg) }) == anyReg;
        reg
    }

    unsafe fn toRegUnchecked(anyReg: AnyReg) -> Reg;

    fn fromFloatReg(floatReg: FloatReg) -> AnyReg {
        let anyReg = (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) });
        assume AnyReg::isFloat(anyReg);
        assume (unsafe { AnyReg::toFloatRegUnchecked(anyReg) }) == floatReg;
        anyReg
    }

    unsafe fn fromFloatRegUnchecked(floatReg: FloatReg) -> AnyReg;

    fn toFloatReg(anyReg: AnyReg) -> FloatReg {
        assert AnyReg::isFloat(anyReg);
        let floatReg = (unsafe { AnyReg::toFloatRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) }) == anyReg;
        floatReg
    }

    unsafe fn toFloatRegUnchecked(anyReg: AnyReg) -> FloatReg;
}

impl TypedOrValueReg {
    fn type(reg: TypedOrValueReg) -> MIRType;

    fn hasTyped(reg: TypedOrValueReg) -> Bool {
        let type = TypedOrValueReg::type(reg);
        type != MIRType::Value && type != MIRType::None
    }

    fn hasValue(reg: TypedOrValueReg) -> Bool {
        TypedOrValueReg::type(reg) == MIRType::Value
    }

    fn fromValueReg(valueReg: ValueReg) -> TypedOrValueReg {
        let reg = (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) });
        assume TypedOrValueReg::type(reg) == MIRType::Value;
        assume (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) }) == valueReg;
        reg
    }

    unsafe fn fromValueRegUnchecked(valueReg: ValueReg) -> TypedOrValueReg;

    fn toValueReg(reg: TypedOrValueReg) -> ValueReg {
        assert TypedOrValueReg::hasValue(reg);
        let valueReg = (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) });
        assume (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) }) == reg;
        valueReg
    }

    unsafe fn toValueRegUnchecked(reg: TypedOrValueReg) -> ValueReg;

    fn fromTypedReg(type: MIRType, typedReg: AnyReg) -> TypedOrValueReg {
        // NOTE: don't support this currently even though it may be okay
        assert type != MIRType::Value;

        let reg = (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) });
        assume TypedOrValueReg::type(reg) == type;
        assume (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) }) == typedReg;
        reg
    }

    unsafe fn fromTypedRegUnchecked(type: MIRType, reg: AnyReg) -> TypedOrValueReg;

    fn toTypedReg(reg: TypedOrValueReg) -> AnyReg {
       assert TypedOrValueReg::hasTyped(reg);
       let typedReg = (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) });
       let type = TypedOrValueReg::type(reg);
       assume (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) }) == reg;
       typedReg
    }

    unsafe fn toTypedRegUnchecked(reg: TypedOrValueReg) -> AnyReg;
}

struct LiveGeneralRegSet;

impl LiveGeneralRegSet {
    fn newEmpty() -> LiveGeneralRegSet;
    fn newVolatile() -> LiveGeneralRegSet;

    fn contains(set: LiveGeneralRegSet, reg: Reg) -> Bool;
    fn add(out newSet: LiveGeneralRegSet, set: LiveGeneralRegSet, reg: Reg);
    fn take(out newSet: LiveGeneralRegSet, set: LiveGeneralRegSet, reg: Reg);

    #[refined]
    fn size(set: LiveGeneralRegSet) -> UInt32 {
        let size = 0_u32;
        for reg in Reg asc {
            if LiveGeneralRegSet::contains(set, reg) {
                size = size + 1_u32;
            }
        }

        size
    }
}

struct LiveFloatRegSet;

impl LiveFloatRegSet {
    fn newEmpty() -> LiveFloatRegSet;
    fn newVolatile() -> LiveFloatRegSet;

    fn contains(set: LiveFloatRegSet, floatReg: FloatReg) -> Bool;
    fn add(out newSet: LiveFloatRegSet, set: LiveFloatRegSet, floatReg: FloatReg);
    fn take(out newSet: LiveFloatRegSet, set: LiveFloatRegSet, floatReg: FloatReg);

    #[refined]
    fn reducedForPush(set: LiveFloatRegSet) -> LiveFloatRegSet {
        let mut newSet = set;
        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if LiveFloatRegSet::contains(newSet, simdReg) {
                LiveFloatRegSet::take(out newSet, newSet, doubleReg);
                LiveFloatRegSet::take(out newSet, newSet, singleReg);
            } else if LiveFloatRegSet::contains(newSet, doubleReg) {
                LiveFloatRegSet::take(out newSet, newSet, singleReg);
            }
        }

        newSet
    }

    #[refined]
    fn size(set: LiveFloatRegSet) -> UInt32 {
        // TODO: mut variable ?
        let size = 0_u32;

        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if LiveFloatRegSet::contains(set, simdReg) {
                size = size + 1_u32;
            }

            if LiveFloatRegSet::contains(set, doubleReg) {
                size = size + 1_u32;
            }

            if LiveFloatRegSet::contains(set, singleReg) {
                size = size + 1_u32;
            }
        }

        size
    }

    #[refined]
    fn pushSizeInBytes(set: LiveFloatRegSet) -> UInt32 {
        let count32 = 0_u32;
        let count64 = 0_u32;
        let count128 = 0_u32;

        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            assert (
              (!LiveFloatRegSet::contains(set, simdReg) && !LiveFloatRegSet::contains(set,
              doubleReg) && !LiveFloatRegSet::contains(set, singleReg)) ||
              (LiveFloatRegSet::contains(set, simdReg) && !LiveFloatRegSet::contains(set,
              doubleReg) && !LiveFloatRegSet::contains(set, singleReg)) || 
              (!LiveFloatRegSet::contains(set, simdReg) && LiveFloatRegSet::contains(set,
              doubleReg) && !LiveFloatRegSet::contains(set, singleReg)) || 
              (!LiveFloatRegSet::contains(set, simdReg) && !LiveFloatRegSet::contains(set,
              doubleReg) && LiveFloatRegSet::contains(set, singleReg))
            );

            if LiveFloatRegSet::contains(set, simdReg) {
                count128 = count128 + 1_u32;
            } else if LiveFloatRegSet::contains(set, doubleReg) {
                count64 = count64 + 1_u32;
            } else if LiveFloatRegSet::contains(set, singleReg) {
                count32 = count32 + 1_u32;
            }
        }

        // adjustment for alignment
        count32 = count32 + ( count32 & 1_u32 );

        (count32 * 4_u32) + (count64 * 8_u32) + (count128 * 16_u32)
    }
}

struct LiveRegSet;

impl LiveRegSet {
    fn gprs(set: LiveRegSet) -> LiveGeneralRegSet;
    fn fpus(set: LiveRegSet) -> LiveFloatRegSet;

    fn containsReg(set: LiveRegSet, reg: Reg) -> Bool {
        let gprs = LiveRegSet::gprs(set);
        LiveGeneralRegSet::contains(gprs, reg)
    }

    fn addReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        LiveGeneralRegSet::add(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn takeReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        LiveGeneralRegSet::take(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn containsFloatReg(set: LiveRegSet, floatReg: FloatReg) -> Bool {
        let fpus = LiveRegSet::fpus(set);
        LiveFloatRegSet::contains(fpus, floatReg)
    }

    fn newEmpty() -> LiveRegSet {
        let gprs = LiveGeneralRegSet::newEmpty();
        let fpus = LiveFloatRegSet::newEmpty();
        LiveRegSet::new(gprs, fpus)
    }

    fn newVolatile() -> LiveRegSet {
        let gprs = LiveGeneralRegSet::newVolatile();
        let fpus = LiveFloatRegSet::newVolatile();
        LiveRegSet::new(gprs, fpus)
    }

    fn new(gprs: LiveGeneralRegSet, fpus: LiveFloatRegSet) -> LiveRegSet {
        let set = (unsafe { LiveRegSet::newUnchecked(gprs, fpus) });
        assume LiveRegSet::gprs(set) == gprs;
        assume LiveRegSet::fpus(set) == fpus;
        set
    }

    unsafe fn newUnchecked(gprs: LiveGeneralRegSet, fpus: LiveFloatRegSet) -> LiveRegSet;
}

struct MoveResolver;

impl MoveResolver {
    fn reset();
    fn addRegMove(data: RegData, count: UInt16);
    fn resolve();
}

enum RegDataType {
    Value,
    UnboxedValue,
    NativeObjectSlots,
    NativeObjectElements,
    TypeTag,
    TaggedProto,
    Class,
    StackIndex,
    JSContext,
}

struct RegData;

impl RegData {
    fn typeOf(data: RegData) -> RegDataType;

    fn isValue(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::Value
    }

    fn fromValue(value: Value) -> RegData {
        let data = (unsafe { RegData::fromValueUnchecked(value) });
        assume RegData::isValue(data);
        assume (unsafe { RegData::toValueUnchecked(data) }) == value;
        data
    }

    unsafe fn fromValueUnchecked(value: Value) -> RegData;

    fn toValue(data: RegData) -> Value {
        assert RegData::isValue(data);
        let value = (unsafe { RegData::toValueUnchecked(data) });
        assume (unsafe { RegData::fromValueUnchecked(value) }) == data;
        value
    }

    unsafe fn toValueUnchecked(data: RegData) -> Value;

    fn isUnboxedValue(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::UnboxedValue
    }

    fn fromUnboxedValue(value: Value) -> RegData {
        let data = (unsafe { RegData::fromUnboxedValueUnchecked(value) });
        assume RegData::isUnboxedValue(data);
        assume (unsafe { RegData::toUnboxedValueUnchecked(data) }) == value;
        data
    }

    unsafe fn fromUnboxedValueUnchecked(value: Value) -> RegData;

    fn toUnboxedValue(data: RegData) -> Value {
        assert RegData::isUnboxedValue(data);
        let value = (unsafe { RegData::toUnboxedValueUnchecked(data) });
        assume (unsafe { RegData::fromUnboxedValueUnchecked(value) }) == data;
        value
    }

    unsafe fn toUnboxedValueUnchecked(data: RegData) -> Value;

    fn isNativeObjectSlots(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::NativeObjectSlots
    }

    fn fromNativeObjectSlots(slots: NativeObjectSlots) -> RegData {
        let data = (unsafe { RegData::fromNativeObjectSlotsUnchecked(slots) });
        assume RegData::isNativeObjectSlots(data);
        assume (unsafe { RegData::toNativeObjectSlotsUnchecked(data) }) == slots;
        data
    }

    unsafe fn fromNativeObjectSlotsUnchecked(slots: NativeObjectSlots) -> RegData;

    fn toNativeObjectSlots(data: RegData) -> NativeObjectSlots {
        assert RegData::isNativeObjectSlots(data);
        let slots = (unsafe { RegData::toNativeObjectSlotsUnchecked(data) });
        assume (unsafe { RegData::fromNativeObjectSlotsUnchecked(slots) }) == data;
        slots
    }

    unsafe fn toNativeObjectSlotsUnchecked(data: RegData) -> NativeObjectSlots;

    fn isNativeObjectElements(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::NativeObjectElements
    }

    fn fromNativeObjectElements(elements: NativeObjectElements) -> RegData {
        let data = (unsafe { RegData::fromNativeObjectElementsUnchecked(elements) });
        assume RegData::isNativeObjectElements(data);
        assume (unsafe { RegData::toNativeObjectElementsUnchecked(data) }) == elements;
        data
    }

    unsafe fn fromNativeObjectElementsUnchecked(slots: NativeObjectElements) -> RegData;

    fn toNativeObjectElements(data: RegData) -> NativeObjectElements {
        assert RegData::isNativeObjectElements(data);
        let elements = (unsafe { RegData::toNativeObjectElementsUnchecked(data) });
        assume (unsafe { RegData::fromNativeObjectElementsUnchecked(elements) }) == data;
        elements
    }

    unsafe fn toNativeObjectElementsUnchecked(data: RegData) -> NativeObjectElements;

    fn isTypeTag(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::TypeTag
    }

    fn fromValueType(valTy: ValueType) -> RegData {
        let data = (unsafe { RegData::fromValueTypeUnchecked(valTy) });
        assume RegData::isTypeTag(data);
        assume (unsafe { RegData::toValueTypeUnchecked(data) }) == valTy;
        data
    }

    unsafe fn fromValueTypeUnchecked(valTy: ValueType) -> RegData;

    fn toValueType(data: RegData) -> ValueType {
        assert RegData::isTypeTag(data);
        let valTy = (unsafe { RegData::toValueTypeUnchecked(data) });
        assume (unsafe { RegData::fromValueTypeUnchecked(valTy) }) == data;
        valTy
    }

    unsafe fn toValueTypeUnchecked(data: RegData) -> ValueType;

    fn isTaggedProto(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::TaggedProto
    }

    fn fromTaggedProto(proto: TaggedProto) -> RegData {
        let data = (unsafe { RegData::fromTaggedProtoUnchecked(proto) });
        assume RegData::isTaggedProto(data);
        assume (unsafe { RegData::toTaggedProtoUnchecked(data) }) == proto;
        data
    }

    unsafe fn fromTaggedProtoUnchecked(proto: TaggedProto) -> RegData;

    fn toTaggedProto(data: RegData) -> TaggedProto {
        assert RegData::isTaggedProto(data);
        let proto = (unsafe { RegData::toTaggedProtoUnchecked(data) });
        assume (unsafe { RegData::fromTaggedProtoUnchecked(proto) }) == data;
        proto
    }

    unsafe fn toTaggedProtoUnchecked(data: RegData) -> TaggedProto;

    fn isClass(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::Class
    }

    fn fromClass(class: Class) -> RegData {
        let data = (unsafe { RegData::fromClassUnchecked(class) });
        assume RegData::isClass(data);
        assume (unsafe { RegData::toClassUnchecked(data) }) == class;
        data
    }

    unsafe fn fromClassUnchecked(class: Class) -> RegData;

    fn toClass(data: RegData) -> Class {
        assert RegData::isClass(data);
        let class = (unsafe { RegData::toClassUnchecked(data) });
        assume (unsafe { RegData::fromClassUnchecked(class) }) == data;
        class
    }

    unsafe fn toClassUnchecked(data: RegData) -> Class;

    fn isStackIndex(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::StackIndex
    }

    fn fromStackIndex(index: UInt64) -> RegData {
        let data = (unsafe { RegData::fromStackIndexUnchecked(index) });
        assume RegData::isStackIndex(data);
        assume (unsafe { RegData::toStackIndexUnchecked(data) }) == index;
        data
    }

    unsafe fn fromStackIndexUnchecked(index: UInt64) -> RegData;

    fn toStackIndex(data: RegData) -> UInt64 {
        assert RegData::isStackIndex(data);
        let index = (unsafe { RegData::toStackIndexUnchecked(data) });
        assume (unsafe { RegData::fromStackIndexUnchecked(index) }) == data;
        index
    }

    unsafe fn toStackIndexUnchecked(data: RegData) -> UInt64;

    fn isJSContext(data: RegData) -> Bool {
        RegData::typeOf(data) == RegDataType::JSContext
    }

    fn fromJSContext(ctx: JSContext) -> RegData {
        let data = (unsafe { RegData::fromJSContextUnchecked(ctx) });
        assume RegData::isJSContext(data);
        assume (unsafe { RegData::toJSContextUnchecked(data) }) == ctx;
        data
    }

    unsafe fn fromJSContextUnchecked(ctx: JSContext) -> RegData;

    fn toJSContext(data: RegData) -> JSContext {
        assert RegData::isJSContext(data);
        let ctx = (unsafe { RegData::toJSContextUnchecked(data) });
        assume (unsafe { RegData::fromJSContextUnchecked(ctx) }) == data;
        ctx
    }

    unsafe fn toJSContextUnchecked(data: RegData) -> JSContext;

    fn readData(data: RegData, offset: Int64) -> RegData {
        if RegData::isUnboxedValue(data) {
            let value = RegData::toUnboxedValue(data);
            return Value::readData(value, offset);
        } else if RegData::isNativeObjectSlots(data) {
            let slots = RegData::toNativeObjectSlots(data);
            return NativeObjectSlots::readData(slots, offset);
        } else if RegData::isNativeObjectElements(data) {
            let elements = RegData::toNativeObjectElements(data);
            return NativeObjectElements::readData(elements, offset);
        }

        assert false;
        data // returning to satisfy compiler
    }
}

struct FloatData;

impl FloatData {
    fn contentType(data: FloatData) -> FloatContentType;

    fn fromDouble(double: Double) -> FloatData {
        let data = (unsafe { FloatData::fromDoubleUnchecked(double) });
        assume FloatData::contentType(data) == FloatContentType::Double;
        assume (unsafe { FloatData::toDoubleUnchecked(data) }) == double;
        data
    }

    unsafe fn fromDoubleUnchecked(double: Double) -> FloatData;

    fn toDouble(data: FloatData) -> Double {
        assert FloatData::contentType(data) == FloatContentType::Double;
        let double = (unsafe { FloatData::toDoubleUnchecked(data) });
        assume (unsafe { FloatData::fromDoubleUnchecked(double) }) == data;
        double
    }

    unsafe fn toDoubleUnchecked(data: FloatData) -> Double;
}

struct StackData;

impl StackData {
    fn isFloat(data: StackData) -> Bool;

    fn size(data: StackData) -> UInt64 {
        if !StackData::isFloat(data) {
            // RegData is always 8 bytes
            return 8_u64;
        } else {
            let floatData = StackData::toFloatData(data);
            let contentType = FloatData::contentType(floatData);
            if contentType == FloatContentType::Single {
                return 4_u64;
            } else if contentType == FloatContentType::Double {
                return 8_u64;
            } else {
                return 16_u64;
            }
        }

        assert false;
        return 0_u64;
    }

    fn fromFloatData(floatData: FloatData) -> StackData {
        let data = (unsafe { StackData::fromFloatDataUnchecked(floatData) });
        assume StackData::isFloat(data);
        assume (unsafe { StackData::toFloatDataUnchecked(data) }) == floatData;
        data
    }

    unsafe fn fromFloatDataUnchecked(floatData: FloatData) -> StackData;

    fn toFloatData(data: StackData) -> FloatData {
        assert StackData::isFloat(data);
        let floatData = (unsafe { StackData::toFloatDataUnchecked(data) });
        assume (unsafe { StackData::fromFloatDataUnchecked(floatData) }) == data;
        floatData
    }

    unsafe fn toFloatDataUnchecked(data: StackData) -> FloatData;

    fn fromRegData(regData: RegData) -> StackData {
        let data = (unsafe { StackData::fromRegDataUnchecked(regData) });
        assume !StackData::isFloat(data);
        assume (unsafe { StackData::toRegDataUnchecked(data) }) == regData;
        data
    }

    unsafe fn fromRegDataUnchecked(regData: RegData) -> StackData;

    fn toRegData(data: StackData) -> RegData {
        assert !StackData::isFloat(data);
        let regData = (unsafe { StackData::toRegDataUnchecked(data) });
        assume (unsafe { StackData::fromRegDataUnchecked(regData) }) == data;
        regData
    }

    unsafe fn toRegDataUnchecked(data: StackData) -> RegData;
}

enum Condition {
    Equal,
    NotEqual,
    Overflow,
    Zero,
    NonZero,
    Signed,
    NotSigned,
    GreaterThan,
    LessThan,
}

struct Address {
    base: Reg,
    offset: Int32,
}

impl Address {
    fn new(base: Reg, offset: Int32) -> Address {
        let address = (unsafe { Address::newUnchecked(base, offset) } );
        assume address.base == base;
        assume address.offset == offset;
        address
    }

    unsafe fn newUnchecked(base: Reg, offset: Int32) -> Address;
}

enum Scale {
    TimesOne,
    TimesTwo,
    TimesFour,
    TimesEight,
}

var ValueScale: Scale = Scale::TimesEight;

struct BaseIndex {
    base: Reg,
    index: Reg,
    scale: Scale,
    offset: UInt32,
}

impl BaseIndex {
    fn new(base: Reg, index: Reg, scale: Scale, offset: UInt32) -> BaseIndex {
        let baseIndex = (unsafe { BaseIndex::newUnchecked(base, index, scale, offset) } );
        assume baseIndex.base == base;
        assume baseIndex.index == index;
        assume baseIndex.scale == scale;
        assume baseIndex.offset == offset;
        baseIndex
    }    

    unsafe fn newUnchecked(base: Reg, index: Reg, scale: Scale, offset: UInt32) -> BaseIndex;
}

struct BaseValueIndex {
    inner: BaseIndex,
}

impl BaseValueIndex {
    fn new(base: Reg, index: Reg, offset: UInt32) -> BaseValueIndex {
        let inner = BaseIndex::new(base, index, ValueScale, offset);
        let baseValueIndex = (unsafe { BaseValueIndex::newUnchecked(inner) } );
        assume baseValueIndex.inner == inner;
        baseValueIndex
    }

    unsafe fn newUnchecked(inner: BaseIndex) -> BaseValueIndex;
}

struct BaseObjectElementIndex {
    inner: BaseValueIndex,
}

impl BaseObjectElementIndex {
    fn new(base: Reg, index: Reg, offset: UInt32) -> BaseObjectElementIndex {
        let inner = BaseValueIndex::new(base, index, offset);
        let baseObjectElementIndex = (unsafe { BaseObjectElementIndex::newUnchecked(inner) } );
        assume baseObjectElementIndex.inner == inner;
        baseObjectElementIndex
    }

    unsafe fn newUnchecked(inner: BaseValueIndex) -> BaseObjectElementIndex;
}

struct BaseObjectSlotIndex {
    inner: BaseValueIndex,
}

impl BaseObjectSlotIndex {
    fn new(base: Reg, index: Reg) -> BaseObjectSlotIndex {
        let inner = BaseValueIndex::new(base, index, 0_u32);
        let baseObjectSlotIndex = (unsafe { BaseObjectSlotIndex::newUnchecked(inner) } );
        assume baseObjectSlotIndex.inner == inner;
        baseObjectSlotIndex
    }

    unsafe fn newUnchecked(inner: BaseValueIndex) -> BaseObjectSlotIndex;
}

enum ABIFunction {
    StringToNumberPure
}

impl ABIFunction {
    fn call(function: ABIFunction) {
        if function == ABIFunction::StringToNumberPure {
            let ctx = RegData::toJSContext(MASM::getData(Reg::Rcx));
            let str = Value::toString(RegData::toUnboxedValue(MASM::getData(Reg::Rdx)));
            let doublePtr = RegData::toStackIndex(MASM::getData(Reg::R8));

            let double = 0.0;
            let result = StringToNumberPure(ctx, str, out double);

            MASM::setBool(Reg::Rax, result);

            if result {
                MASM::stackStore(doublePtr,
                StackData::fromFloatData(FloatData::fromDouble(double)));
            }
        } else {
            assert false;
        }
    }
}

ir MASM {
    // NOTE: Needs to be implemented to call the equivalent
    // op with string as argument.
    op AssumeUnreachable() {
        assert false;
    }

    op Mov(srcReg: Reg, dstReg: Reg) {
      MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op Move32Imm32(srcInt32: Int32, dstReg: Reg) {
        MASM::setInt32(dstReg, srcInt32);
    }

    op MoveValue(srcReg: ValueReg, dstReg: ValueReg) {
        MASM::setValue(dstReg, MASM::getValue(srcReg));
    }

    op MoveDouble(srcReg: FloatReg, dstReg: FloatReg) {
        MASM::setDouble(dstReg, MASM::getDouble(srcReg));
    }

    op MovePtrBoolImmWord(b: Bool, dstReg: Reg) {
        MASM::setBool(dstReg, b);
    }

    // this op corresponds to an overload of the MoveValue op
    // that takes an immediate Value operand
    op MoveValueImm(value: Value, dstReg: ValueReg) {
        MASM::setValue(dstReg, value);
    }

    op MovePtrImmGCPtrObject(object: Object, dstReg: Reg) {
        MASM::setObject(dstReg, object);
    }

    op Cmp32Move32(condition: Condition, lhsReg: Reg, rhsReg: Reg, srcReg: Reg, dstReg: Reg) {
        assert (condition == Condition::GreaterThan || condition == Condition::LessThan);

        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);
        let srcInt32 = MASM::getInt32(srcReg);

        if condition == Condition::GreaterThan && lhsInt32 > rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        }
    }

    op ReserveStack(amount: UInt32) {
        MASM::reserveStack(amount);
    }

    op AddToStackPtrImm32(amount: Int32) {
        let stackPointer = MASM::getStackIndex(Reg::Rsp);

        let newStackPointer = stackPointer + (amount as UInt64);
        assert (newStackPointer as Int64) >= 0_i64;

        MASM::setStackIndex(Reg::Rsp, newStackPointer);
    }

    op FreeStack(amount: UInt32) {
        MASM::freeStack(amount);
    }

    op MoveStackPtrTo(destReg: Reg) {
        MASM::setStackIndex(destReg, MASM::getStackIndex(Reg::Rsp));
    }

    // TODO: loop through all the registers and push them onto the stack
    // if they are in `set`.
    op PushRegsInMask(set: LiveRegSet) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveFloatRegSet::reducedForPush(LiveRegSet::fpus(set)); 

        for reg in Reg desc {
            if LiveGeneralRegSet::contains(gprs, reg) {
                MASM::stackPushReg(reg);
            }
        }

        for phyReg in PhyFloatReg desc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if LiveFloatRegSet::contains(fpus, simdReg) {
                MASM::stackPushFloatReg(simdReg); 
            } else if LiveFloatRegSet::contains(fpus, doubleReg) {
                MASM::stackPushFloatReg(doubleReg); 
            } else if LiveFloatRegSet::contains(fpus, singleReg) {
                MASM::stackPushFloatReg(singleReg); 
            }
        }

    }

    // TODO: loop through all the registers and pop them off the stack if
    // they are in `set` and not in `ignore`.
    op PopRegsInMaskIgnore(set: LiveRegSet, ignore: LiveRegSet) {
        let fpus = LiveFloatRegSet::reducedForPush(LiveRegSet::fpus(set)); 
        let gprs = LiveRegSet::gprs(set);

        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);
        
            if LiveFloatRegSet::contains(fpus, simdReg) {
                if !LiveRegSet::containsFloatReg(ignore, simdReg) {
                    MASM::stackPopFloatReg(simdReg);
                } else {
                    MASM::stackPop();
                }
            } else if LiveFloatRegSet::contains(fpus, doubleReg) {
                if !LiveRegSet::containsFloatReg(ignore, doubleReg) {
                    MASM::stackPopFloatReg(doubleReg);
                } else {
                    MASM::stackPop();
                }
            } else if LiveFloatRegSet::contains(fpus, singleReg) {
                if !LiveRegSet::containsFloatReg(ignore, singleReg) {
                    MASM::stackPopFloatReg(singleReg);
                } else {
                    MASM::stackPop();
                }
            }
        }

        
        for reg in Reg asc {
            if LiveGeneralRegSet::contains(gprs, reg) {
                if !LiveRegSet::containsReg(ignore, reg) {
                    MASM::stackPopReg(reg);
                } else {
                    MASM::stackPop();
                }
            }
        }
    }

    op SetupUnalignedABICall(scratchReg: Reg) {
        //let stackPtr = MASM::getStackIndex(Reg::Rsp);
        //MASM::setStackIndex(scratchReg, stackPtr);
        //stackPtr = ~15_u64 & stackPtr;
        //MASM::setStackIndex(Reg::Rsp, stackPtr);
        //MASM::stackPushReg(scratchReg);
    }

    op LoadJSContext(destReg: Reg) {
        let ctx = runtimeMainContextPtr();
        let data = RegData::fromJSContext(ctx);
        MASM::setData(destReg, data);
    }

    op PassABIArgReg(reg: Reg, count: UInt16) {
        MoveResolver::addRegMove(MASM::getData(reg), count); 
    }

    op CallWithABI(function: ABIFunction) {
        MoveResolver::resolve();
        ABIFunction::call(function);
        //MASM::stackPopReg(Reg::Rsp);
    }

    op StoreCallPointerResult(reg: Reg) {
        if reg != Reg::Rax {
            MASM::setData(reg, MASM::getData(Reg::Rax));
        }
    }

    op StoreBool(bool: Bool, reg: Reg) {
        MASM::setBool(reg, bool);
    }

    op StoreBoolValue(bool: Bool, valueReg: ValueReg) {
        MASM::setValue(valueReg, Value::fromBool(bool));
    }

    op Jump(label target: MASM) {
      goto target;
    }

    op Load32(int32: Int32, dstReg: Reg) {
        MASM::setInt32(dstReg, int32);
    }

    op Load32Address(address: Address, dstReg: Reg) {
        let baseData = MASM::getData(address.base);
        let data = RegData::readData(baseData, address.offset);
        let value = RegData::toValue(data);
        let int32 = Value::toInt32(value);
        MASM::setInt32(dstReg, int32);
    }

    op LoadDoubleAddress(address: Address, dstReg: FloatReg) {
        let baseData = MASM::getData(address.base);
        if RegData::isStackIndex(baseData) {
            let stackIndex = RegData::toStackIndex(baseData);
            let stackIndex = stackIndex + address.offset;
            let stackData = MASM::stackLoad(stackIndex);
            MASM::setFloatData(dstReg, StackData::toFloatData(stackData));
        } else {
            let data = RegData::readData(baseData, address.offset);
            let value = RegData::toValue(data);
            let double = Value::toDouble(value);
            MASM::setDouble(dstReg, double);
        }
    }

    op LoadValueAddress(address: Address, dstReg: ValueReg) {
        let baseData = MASM::getData(address.base);    
        let data = RegData::readData(baseData, address.offset);
        let value = RegData::toValue(data);
        MASM::setValue(dstReg, value);
    }

    op LoadTypedOrValueAddress(address: Address, dstReg: TypedOrValueReg) {
        let baseData = MASM::getData(address.base);
        let data = RegData::readData(baseData, address.offset);
        let value = RegData::toValue(data);
        if TypedOrValueReg::hasValue(dstReg) {
            MASM::setValue(TypedOrValueReg::toValueReg(dstReg), value);
        } else {
            assert TypedOrValueReg::hasTyped(dstReg);
            MASM::loadUnboxedValue(value, TypedOrValueReg::type(dstReg),
                    TypedOrValueReg::toTypedReg(dstReg))
        }
    }

    op LoadPtrAddress(address: Address, dstReg: Reg) {
        let baseData = MASM::getData(address.base);
        let data = RegData::readData(baseData, address.offset);
        MASM::setData(dstReg, data);
    }

    op LoadStringIndexValue(strReg: Reg, destReg: Reg, label failure: MASM) {
        assert strReg != destReg;

        let string = MASM::getString(strReg);

        if !String::hasIndexValue(string) {
            goto failure;
        }

        let index = String::getIndexValue(string);
        // TODO: may need some assumes to ensure length is positive after cast
        MASM::setInt32(destReg, index as Int32);
    }

    op TagValue(valTy: ValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == ValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        } else if valTy == ValueType::Bool {
            let b = MASM::getBool(payload);
            let val = Value::fromBool(b);
            MASM::setValue(dest, val);
        } else if valTy == ValueType::String {
            let s = MASM::getString(payload);
            let val = Value::fromString(s);
            MASM::setValue(dest, val);
        } else if valTy == ValueType::Symbol {
            let s = MASM::getSymbol(payload);
            let val = Value::fromSymbol(s);
            MASM::setValue(dest, val);
        } else if valTy == ValueType::BigInt {
            let b = MASM::getBigInt(payload);
            let val = Value::fromBigInt(b);
            MASM::setValue(dest, val);
        }
    }

    op EnsureDouble(srcReg: ValueReg, destReg: FloatReg, label failure: MASM) {
        let value = MASM::getValue(srcReg);
        let valTy = Value::typeOf(value);

        if valTy == ValueType::Double {
            let double = Value::toDouble(value);
            MASM::setDouble(destReg, double);
        } else if valTy == ValueType::Int32 {
            let int32 = Value::toInt32(value);
            let double = int32 as Double;
            MASM::setDouble(destReg, double);
        } else {
            goto failure;
        }
    }

    op BoxDouble(srcReg: FloatReg, valueReg: ValueReg, scratchReg: FloatReg) {
        let double = MASM::getDouble(srcReg);
        let value = Value::fromDouble(double);
        MASM::setValue(valueReg, value);
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
      let value = MASM::getValue(valueReg);
      MASM::setInt32(int32Reg, Value::toInt32(value)); 
    }

    op UnboxBoolean(valueReg: ValueReg, boolReg: Reg) {
      let value = MASM::getValue(valueReg);
      MASM::setBool(boolReg, Value::toBool(value));
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    // Note: this is a no-op in Firefox since TaggedProtos
    // can be directly treated as Objects without explicit
    // unboxing.
    op UnboxObjectProto(srcReg: Reg, destReg: Reg) {
        let data = MASM::getData(srcReg);
        let proto = RegData::toTaggedProto(data);
        let object = TaggedProto::toObject(proto);
        MASM::setObject(destReg, object);
    } 

    op FallibleUnboxObject(valueReg: ValueReg, objectReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if !valueIsObject {
            goto failure;
        }

        let object = Value::toObject(value);
        MASM::setObject(objectReg, object);
    }

    op FallibleUnboxBoolean(valueReg: ValueReg, boolReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if !valueIsBool {
            goto failure;
        }

        let bool = Value::toBool(value);
        MASM::setBool(boolReg, bool);
    }

    op UnboxString(valueReg: ValueReg, stringReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setString(stringReg, Value::toString(value));
    }

    op UnboxSymbol(valueReg: ValueReg, symbolReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setSymbol(symbolReg, Value::toSymbol(value));
    }

    op UnboxBigInt(valueReg: ValueReg, bigIntReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setBigInt(bigIntReg, Value::toBigInt(value));
    }

    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: ValueType) {
        let value = MASM::getValue(valueReg);
        MASM::unboxNonDouble(value, dstReg, valTy);    
    }

    // NOTE: This Op needs to be implemented as a Phantom Op on the
    // C++ side since Firefox implicitly reinterprets booleans
    // as int32 within registers.
    op CastBoolToInt32(int32Reg: Reg) {
        let bool = MASM::getBool(int32Reg);
        if bool {
            MASM::setInt32(int32Reg, 1_i32);
        } else {
            MASM::setInt32(int32Reg, 0_i32);
        }
    }

    op ConvertInt32ValueToDouble(valueReg: ValueReg) {
        let value = MASM::getValue(valueReg);

        if !Value::isInt32(value) {
            return;
        }

        let int32 = Value::toInt32(value);
        let double = int32 as Double;
        MASM::setValue(valueReg, Value::fromDouble(double));
    }

    op ConvertInt32ToDouble(srcReg: Reg, destReg: FloatReg) {
        let int32 = MASM::getInt32(srcReg);
        let double = int32 as Double;
        MASM::setDouble(destReg, double);
    }

    op BranchTestNumber(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsNumber = Value::isInt32(value) || Value::isDouble(value);

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestDouble(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsDouble = Value::isDouble(value);

        if condition == Condition::Equal && valueIsDouble {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsDouble {
            goto branch;
        }
    }

    op BranchObject(
        condition: Condition,
        lhsReg: Reg,
        rhsReg: Reg,
        label branch: MASM,
    ) {
        let lhs = MASM::getObject(lhsReg);
        let rhs = MASM::getObject(rhsReg);
        let isEqual = lhs == rhs;

        if condition == Condition::Equal {
            if isEqual {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !isEqual {
                goto branch;
            }
        }
    }

    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsInt32 = Value::isInt32(value);

        if condition == Condition::Equal && valueIsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsInt32 {
            goto branch;
        }
    }

    op BranchTestInt32Truthy(truthy: Bool, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let int32 = Value::toInt32(value);

        if (!truthy && int32 == 0_i32) || (truthy && int32 != 0_i32) {
            goto branch;
        }
    }

    op BranchTestBoolean(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if condition == Condition::Equal && valueIsBool {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBool {
            goto branch;
        }
    }

    op BranchIfTrueBool(reg: Reg, label branch: MASM) {
        let bool = MASM::getBool(reg);
        if bool {
            goto branch;
        }
    }

    op BranchTestString(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsString = Value::isString(value);

        if condition == Condition::Equal && valueIsString {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsString {
            goto branch;
        }
    }

    op BranchTestSymbol(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsSymbol = Value::isSymbol(value);

        if condition == Condition::Equal && valueIsSymbol {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsSymbol {
            goto branch;
        }
    }

    op BranchTestBigInt(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBigInt = Value::isBigInt(value);

        if condition == Condition::Equal && valueIsBigInt {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBigInt {
            goto branch;
        }
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
      assert condition == Condition::Equal || condition == Condition::NotEqual;
      let value = MASM::getValue(valueReg);
      let valueIsObject = Value::isObject(value);

      if condition == Condition::Equal && valueIsObject {
          goto branch;
      }

      if condition == Condition::NotEqual && !valueIsObject {
          goto branch;
      }
    }

    // Note: this is a wrapper around branchTestPtr for when
    // the register contains a TaggedProto
    op BranchTestNullProto(reg: Reg, label branch: MASM) {
        let data = MASM::getData(reg);
        let proto = RegData::toTaggedProto(data);

        if TaggedProto::isNull(proto) {
            goto branch;
        }
    }

    // Note: this is a wrapper around branchPtr for when
    // the register contains a TaggedProto
    op BranchTestLazyProto(reg: Reg, label branch: MASM) {
        let data = MASM::getData(reg);
        let proto = RegData::toTaggedProto(data);

        if TaggedProto::isLazy(proto) {
            goto branch;
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op BranchTestUndefined(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsUndefined = Value::isUndefined(value);

        if condition == Condition::Equal && valueIsUndefined{
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsUndefined {
            goto branch;
        }
    }

    op BranchTestMagic(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsMagic = Value::isMagic(value);

        if condition == Condition::Equal {
            if valueIsMagic {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsMagic {
                goto branch;
            }
        }
    }

    op BranchTestObjIsFunction(
        condition: Condition, objectReg: Reg, scratchReg: Reg,
        spectreRegToZero: Reg, label branch: MASM
    ) {

        assert scratchReg != spectreRegToZero;
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let isClass = class == Class::functionClass() || class == Class::extendedFunctionClass();

        if condition == Condition::Equal && isClass {
            goto branch;
        }

        if condition == Condition::NotEqual && !isClass {
            goto branch;
        }

        MASM::setInt32(scratchReg, 0_i32);
    }

    op BranchTestObjIsFunctionNoSpectreMitigations(
        condition: Condition, objectReg: Reg, scratchReg: Reg, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let isClass = class == Class::functionClass() || class == Class::extendedFunctionClass();
        
        if condition == Condition::Equal && isClass {
            goto branch;
        } else if condition == Condition::NotEqual && !isClass {
            goto branch;
        }
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert objectReg != scratchReg;
        assert spectreRegToZero != scratchReg;

        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectClass(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert scratchReg != spectreRegToZero;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }

        MASM::setInt32(scratchReg, 0_i32);
    }

    op BranchTestObjectClassNoSpectreMitigations(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }
    }

    op BranchIfNonNativeObj(objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsNative = Class::isNativeObject(class);

        if !objectIsNative {
            goto branch;
        }
    }

    op BranchTestObjectIsProxy(proxy: Bool, objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsProxy = Class::isProxyObject(class);

        if !proxy && !objectIsProxy {
            goto branch;
        } else if proxy && objectIsProxy {
            goto branch;
        }
    }

    // NOTE: This Op needs to be implemented on the C++ to delegate to the
    // appropriate overload of Branch32Imm since Cachet doesn't have overloading.
    op Branch32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );

        let lhsInt32 = MASM::getInt32(lhsReg);

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op Branch32AddressImm32(
        condition: Condition, address: Address, rhsInt32: Int32, label branch:MASM
    ) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );


        let baseData = MASM::getData(address.base);
        let data = RegData::readData(baseData, address.offset);
        let lhsInt32 = Value::toInt32(RegData::toUnboxedValue(data));

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op BranchTest32(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(lhsReg);
      let rhsInt32 = MASM::getInt32(rhsReg);

      let result = lhsInt32 & rhsInt32;

      assert (
        condition == Condition::Zero ||
        condition == Condition::NonZero ||
        condition == Condition::Signed ||
        condition == Condition::NotSigned
      );

      if condition == Condition::Zero {
        if result == 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NonZero {
        if result != 0_i32 {
          goto branch;
        }
      } else if condition == Condition::Signed {
        if result < 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NotSigned {
        if result > 0_i32 {
          goto branch;
        }
      }
    }

    op BranchTest32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(lhsReg);

      let result = lhsInt32 & rhsInt32;

      assert (
        condition == Condition::Zero ||
        condition == Condition::NonZero ||
        condition == Condition::Signed ||
        condition == Condition::NotSigned
      );

      if condition == Condition::Zero {
        if result == 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NonZero {
        if result != 0_i32 {
          goto branch;
        }
      } else if condition == Condition::Signed {
        if result < 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NotSigned {
        if result > 0_i32 {
          goto branch;
        }
      }
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 + rhsInt32;
      
      assert condition == Condition::Overflow;
      if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchAdd32Imm(condition: Condition, lhsInt32: Int32, dstReg: Reg, label branch: MASM) {
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 + rhsInt32;

      assert condition == Condition::Overflow;
      if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchSub32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 - rhsInt32;

      assert condition == Condition::Overflow;

      let rhsInt32Neg = -rhsInt32;
      let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

      if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
          goto branch;
      } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchSub32Imm(condition: Condition, rhsInt32: Int32, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 - rhsInt32;

      assert condition == Condition::Overflow;

      let rhsInt32Neg = -rhsInt32;
      let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

      if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
          goto branch;
      } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchMul32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 * rhsInt32;

      assert condition == Condition::Overflow;

      let resultWide = (lhsInt32 as Int64) * (rhsInt32 as Int64);
      if (result as Int64) != resultWide {
        goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    // TODO(abhishekc-sharma): handle isUnsigned and volatile registers.
    op FlexibleDivMod32(rhsReg: Reg, lhsOutputReg: Reg, remReg: Reg) {
      let lhsInt32 = MASM::getInt32(lhsOutputReg);
      let rhsInt32 = MASM::getInt32(rhsReg);

      let quotient = lhsInt32 / rhsInt32;
      let remainder = lhsInt32 % rhsInt32;

      MASM::setInt32(lhsOutputReg, quotient);
      MASM::setInt32(remReg, remainder);
    }

    // TODO(abhishekc-sharma): handle isUnsigned and volatile registers.
    op FlexibleRemainder32(rhsReg: Reg, lhsOutputReg: Reg) {
      let lhsInt32 = MASM::getInt32(lhsOutputReg);
      let rhsInt32 = MASM::getInt32(rhsReg);

      let remainder = lhsInt32 % rhsInt32;
      MASM::setInt32(lhsOutputReg, remainder);
    }

    op Neg32(valueReg: Reg) {
      let valueInt32 = MASM::getInt32(valueReg);
      let result = -valueInt32;

      MASM::setInt32(valueReg, result);
    }

    op Not32(valueReg: Reg) {
      let valueInt32 = MASM::getInt32(valueReg);
      let result = ~valueInt32;

      MASM::setInt32(valueReg, result);
    }

    op Or32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 | rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op Xor32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 ^ rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op And32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 & rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    op FlexibleLshift32(shiftReg: Reg, srcDestReg: Reg) {
      let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
      let srcInt32 = MASM::getInt32(srcDestReg);

      let result = srcInt32 << shiftInt32;

      MASM::setInt32(srcDestReg, result);
    }

    op FlexibleRshift32Arithmetic(shiftReg: Reg, srcDestReg: Reg) {
      let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
      let srcInt32 = MASM::getInt32(srcDestReg);

      let result = srcInt32 >> shiftInt32;

      MASM::setInt32(srcDestReg, result);
    }

    op FlexibleRshift32(shiftReg: Reg, srcDestReg: Reg) {
      let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
      let srcInt32 = MASM::getInt32(srcDestReg);

      let result = ((srcInt32 as UInt32) >> (shiftInt32 as UInt32)) as Int32;

      MASM::setInt32(srcDestReg, result);
    }

    op TestObjectSet(condition: Condition, valueReg: ValueReg, dstReg: Reg) {
        assert (condition == Condition::Equal || condition == Condition::NotEqual);

        let value = MASM::getValue(valueReg);
        let isObject = Value::isObject(value);

        MASM::setBool(dstReg, false);

        if condition == Condition::Equal && isObject {
            MASM::setBool(dstReg, true);
        } else if condition == Condition::NotEqual && !isObject {
            MASM::setBool(dstReg, true);
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot as UInt32));
    }

    op LoadArgumentsObjectLength(
        objectReg: Reg, outputReg: Reg, label failure: MASM
    ) {
        let obj = MASM::getObject(objectReg);
        let argObj = Object::toArgumentsObject(obj);
        let length = ArgumentsObject::getInitialLength(argObj);
        MASM::setInt32(outputReg, length as Int32);
        if length & ArgumentsObject::lengthOverridenBit != 0_u32 {
            goto failure;
        }
        MASM::setInt32(outputReg, (length >> ArgumentsObject::packedBitsCount) as Int32)
    }

    op LoadObjectProto(objectReg: Reg, protoReg: Reg) {
        let object = MASM::getObject(objectReg);

        let shape = Object::shapeOf(object);
        let baseShape = Shape::baseShapeOf(shape);
        let proto = BaseShape::protoOf(baseShape);
        let data = RegData::fromTaggedProto(proto);

        MASM::setData(protoReg, data);
    }

    op AddDouble(srcReg: FloatReg, destReg: FloatReg) {
        let lhs = MASM::getDouble(destReg);
        let rhs = MASM::getDouble(srcReg);

        let result = lhs + rhs;
        MASM::setDouble(destReg, result);
    }

    fn loadUnboxedValue(value: Value, type: MIRType, dstReg: AnyReg) {
        if AnyReg::isFloat(dstReg) {
            MASM::loadInt32OrDouble(value, AnyReg::toFloatReg(dstReg));
        } else {
            MASM::unboxNonDouble(value, AnyReg::toReg(dstReg), ValueType::fromMIRType(type));
        }
    }

    fn unboxNonDouble(value: Value, dstReg: Reg, valTy: ValueType) {
        assert valTy != ValueType::Double;

        if valTy == ValueType::Object {
            let o = Value::toObject(value);
            MASM::setObject(dstReg, o);
        } else if valTy == ValueType::Int32 {
            let i = Value::toInt32(value);
            MASM::setInt32(dstReg, i);
        } else if valTy == ValueType::Bool {
            let b = Value::toBool(value);
            MASM::setBool(dstReg, b);
        } else if valTy == ValueType::String {
            let s = Value::toString(value);
            MASM::setString(dstReg, s);
        } else if valTy == ValueType::Symbol {
            let s = Value::toSymbol(value);
            MASM::setSymbol(dstReg, s);
        } else if valTy == ValueType::BigInt {
            let b = Value::toBigInt(value);
            MASM::setBigInt(dstReg, b);
        }
    }

    fn loadInt32OrDouble(value: Value, dstReg: FloatReg) {
        if Value::isInt32(value) {
            let int32 = Value::toInt32(value);
            let double = int32 as Double;
            MASM::setDouble(dstReg, double);
        } else if Value::isDouble(value) {
            let double = Value::toDouble(value);
            MASM::setDouble(dstReg, double);
        }

        assert false;
    }

    fn getData(reg: Reg) -> RegData;
    fn setData(reg: Reg, data: RegData);

    fn getStackIndex(reg: Reg) -> UInt64;
    fn setStackIndex(reg: Reg, index: UInt64);

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);

    fn getBool(reg: Reg) -> Bool;
    fn setBool(reg: Reg, bool: Bool);

    fn getString(reg: Reg) -> String;
    fn setString(reg: Reg, string: String);

    fn getSymbol(reg: Reg) -> Symbol;
    fn setSymbol(reg: Reg, symbol: Symbol);

    fn getBigInt(reg: Reg) -> BigInt;
    fn setBigInt(reg: Reg, bigInt: BigInt);

    fn getFloatData(floatReg: FloatReg) -> FloatData;
    fn setFloatData(floatReg: FloatReg, data: FloatData);

    fn getDouble(floatReg: FloatReg) -> Double;
    fn setDouble(floatReg: FloatReg, double: Double);

    fn reserveStack(amount: UInt32) {
        let stackPointer = MASM::getStackIndex(Reg::Rsp);

        let newStackPointer = stackPointer - amount;
        assert (newStackPointer as Int64) >= 0_i64;

        MASM::setStackIndex(Reg::Rsp, newStackPointer);
    }

    fn freeStack(amount: UInt32) {
        let stackPointer = MASM::getStackIndex(Reg::Rsp);
        let newStackPointer = stackPointer + amount;
        MASM::setStackIndex(Reg::Rsp, newStackPointer);
    }

    fn stackPush(data: StackData);
    fn stackPop() -> StackData;

    fn stackStore(idx: UInt64, data: StackData);
    fn stackLoad(idx: UInt64) -> StackData;

    fn stackPushReg(reg: Reg) {
        let regData = MASM::getData(reg);
        let data = StackData::fromRegData(regData);
        MASM::stackPush(data);
    }

    fn stackPopReg(reg: Reg) {
        let data = MASM::stackPop();
        let regData = StackData::toRegData(data);
        MASM::setData(reg, regData);
    }

    fn stackPushFloatReg(floatReg: FloatReg) {
        let floatData = MASM::getFloatData(floatReg);
        let data = StackData::fromFloatData(floatData);
        MASM::stackPush(data);
    }

    fn stackPopFloatReg(floatReg: FloatReg) {
        let data = MASM::stackPop();
        let floatData = StackData::toFloatData(data);
        MASM::setFloatData(floatReg, floatData);
    }

    fn loadRegAddress(address: Address, reg: Reg) {
       let baseData = MASM::getData(address.base);

       if RegData::isStackIndex(baseData) {
            let stackIndex = RegData::toStackIndex(baseData);
            stackIndex = stackIndex + address.offset;
            let stackData = MASM::stackLoad(stackIndex);
            let regData = StackData::toRegData(stackData);
            MASM::setData(reg, regData);
       } else {
            assert false;
       }
    }

    fn storeFloatRegAddress(floatReg: FloatReg, address: Address) {
        let baseData = MASM::getData(address.base);

        if RegData::isStackIndex(baseData) {
            let stackIndex = RegData::toStackIndex(baseData);
            stackIndex = stackIndex + address.offset;
            let floatData = MASM::getFloatData(floatReg);
            let stackData = StackData::fromFloatData(floatData);
            MASM::stackStore(stackIndex, stackData);
        } else {
            assert false;
        }
    }

    fn loadFloatRegAddress(address: Address, floatReg: FloatReg) {
       let baseData = MASM::getData(address.base);

       if RegData::isStackIndex(baseData) {
            let stackIndex = RegData::toStackIndex(baseData);
            stackIndex = stackIndex + address.offset;
            let stackData = MASM::stackLoad(stackIndex);
            let floatData = StackData::toFloatData(stackData);
            assert FloatData::contentType(floatData) == floatReg.type;
            MASM::setFloatData(floatReg, floatData);
       } else {
            assert false;
       }
    }
}

//impl MASM {
    //spec var mut regs: Map<Reg, Value>;
    //spec var mut valueRegs: Map<ValueReg, Value>;

    //fn getValue(valueReg: ValueReg) -> Value;

    //refine fn getValue(valueReg: ValueReg) -> Value {
        //Map::get(MASM::valueRegs, valueReg)
    //}

    //fn setValue(valueReg: ValueReg, value: Value);

    //refine fn setValue(valueReg: ValueReg, value: Value) {
        //MASM::valueRegs = Map::set(MASM::valueRegs, valueReg, value);
    //}

    //spec fn getUnboxedValue(reg: Reg) -> Value {
        //Map::get(MASM::regs, reg)
    //}

    //fn setUnboxedValue(reg: Reg, value: Value);

    //refine fn setUnboxedValue(reg: Reg, value: Value) {
        //MASM::regs = Map::set(MASM::regs, reg, value);
    //}

    //fn getInt32(reg: Reg) -> Int32;

    //refine fn getInt32(reg: Reg) -> Int32 {
        //Value::toInt32(MASM::getUnboxedValue(reg))
    //}

    //fn setInt32(reg: Reg, int32: Int32);

    //refine fn setInt32(reg: Reg, int32: Int32) {
        //MASM::setUnboxedValue(reg, Value::fromInt32(int32));
    //}

    //fn getObject(reg: Reg) -> Object;

    //refine fn getObject(reg: Reg) -> Object {
        //Value::toObject(MASM::getUnboxedValue(reg))
    //}

    //fn setObject(reg: Reg, object: Object);

    //refine fn setObject(reg: Reg, object: Object) {
        //MASM::setUnboxedValue(reg, Value::fromObject(object));
    //}
//}
