// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

var zero: Int32;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;

    // ...

    fn isInt32(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Int32
    }

    fn fromInt32(int32: Int32) -> Value {
        let value = (unsafe { Value::fromInt32Unchecked(int32) });
        assume Value::isInt32(value);
        assume (unsafe { Value::toInt32Unchecked(value) }) == int32;
        value
    }

    unsafe fn fromInt32Unchecked(value: Int32) -> Value;

    fn toInt32(value: Value) -> Int32 {
        assert Value::isInt32(value);
        let int32 = (unsafe { Value::toInt32Unchecked(value) });
        assume (unsafe { Value::fromInt32Unchecked(int32) }) == value;
        int32
    }

    unsafe fn toInt32Unchecked(value: Value) -> Int32;

    fn isBool(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Bool
    }

    fn fromBool(bool: Bool) -> Value {
        let value = (unsafe { Value::fromBoolUnchecked(bool) });
        assume Value::isBool(value);
        assume (unsafe { Value::toBoolUnchecked(value) }) == bool;
        value
    }

    unsafe fn fromBoolUnchecked(value: Bool) -> Value;

    fn toBool(value: Value) -> Bool {
        assert Value::isBool(value);
        let bool = (unsafe { Value::toBoolUnchecked(value) });
        assume (unsafe { Value::fromBoolUnchecked(bool) }) == value;
        bool
    }

    unsafe fn toBoolUnchecked(value: Value) -> Bool;

    fn isNull(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Null
    }

    fn isMagic(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Magic
    }

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = (unsafe { Value::fromObjectUnchecked(object) });
        assume Value::isObject(value);
        assume (unsafe { Value::toObjectUnchecked(value) }) == object;
        value
    }

    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = (unsafe { Value::toObjectUnchecked(value) });
        assume (unsafe { Value::fromObjectUnchecked(object) }) == value;
        object
    }

    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn protoOf(object: Object) -> Value;
    fn protoOf(object: Object) -> Value {
        (unsafe { Object::protoOfUnchecked(heap, object) })
    }

    unsafe fn protoOfUnchecked(heap: Heap, object: Object) -> Value;
}

struct Reg;
struct ValueReg;

enum Condition {
    Equal,
    NotEqual,
}

ir MASM {
    op Jump(label dst: MASM) {
        goto dst;
    }

    op StoreBool(bool: Bool, reg: Reg) {
        MASM::setBool(reg, bool);
    }

    op StoreBoolValue(bool: Bool, valueReg: ValueReg) {
        MASM::setValue(valueReg, Value::fromBool(bool));
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op BranchTestMagic(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsMagic = Value::isMagic(value);

        if condition == Condition::Equal {
            if valueIsMagic {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsMagic {
                goto branch;
            }
        }
    }

    op BranchObject(
        condition: Condition,
        lhsReg: Reg,
        rhsReg: Reg,
        label branch: MASM,
    ) {
        let lhs = MASM::getObject(lhsReg);
        let rhs = MASM::getObject(rhsReg);
        let isEqual = lhs == rhs;

        if condition == Condition::Equal {
            if isEqual {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !isEqual {
                goto branch;
            }
        }
    }


    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op LoadObjectProto(objectReg: Reg, protoReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(protoReg, Object::protoOf(object));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getBool(reg: Reg) -> Bool;
    fn setBool(reg: Reg, bool: Bool);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);
}

struct ValueId;
struct ObjectId;

ir CacheIR emits MASM {
    op GuardToObject(valueId: ValueId, objectId: ObjectId) {
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);

        CacheIR::addFailurePath(out label failure);

        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }

    op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        let lhsReg = CacheIR::useValueReg(lhsId);
        let protoReg = CacheIR::useObjectReg(protoId);
        let scratchReg = CacheIR::allocateReg();

        CacheIR::addFailurePath(out label failure);

        label loopHead: MASM;
        label returnFalse: MASM;
        label returnTrue: MASM;
        label done: MASM;

        emit MASM::BranchTestObject(Condition::NotEqual, lhsReg, returnFalse);
        emit MASM::UnboxObject(lhsReg, scratchReg);
        emit MASM::LoadObjectProto(scratchReg, lhsReg);

        bind loopHead;
        emit MASM::BranchTestNull(Condition::Equal, lhsReg, returnFalse);
        emit MASM::BranchTestMagic(Condition::Equal, lhsReg, failure);

        emit MASM::BranchTestObject(Condition::NotEqual, lhsReg, returnFalse);
        emit MASM::UnboxObject(lhsReg, scratchReg);
        emit MASM::BranchObject(Condition::Equal, scratchReg, protoReg, returnTrue);

        emit MASM::LoadObjectProto(scratchReg, lhsReg);
        //emit MASM::StoreBool(true, protoReg); <-- uncomment to induce error
        emit MASM::Jump(loopHead);

        bind returnFalse;
        emit MASM::StoreBoolValue(false, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind returnTrue;
        emit MASM::StoreBoolValue(true, CacheIR::outputReg);

        bind done;

        CacheIR::releaseReg(scratchReg);
    }

    fn addFailurePath(out label failure: MASM);

    fn allocateReg() -> Reg;
    fn releaseReg(reg: Reg);

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;
}

// interpreter version:
//ir CacheIR {
    //op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        //CacheIR::getFailurePath(out label failure);

        //let lhs = CacheIR::getValue(lhsId);
        //let proto = CacheIR::getObject(protoId);

        //if !Value::isObject(lhs) {
            //goto failure;
        //}
        //let mut currentObject = Value::toObject(lhs);
        //let mut currentProto = Object::getProto(currentObject);

        //loop {
            //if Value::isNull(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //if Value::isMagic(currentProto) {
                //goto failure;
            //}

            //if !Value::isObject(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //currentObject = Value::toObject(currentProto);
            //if currentObject == proto {
                //CacheIR::setOutput(Value::fromBool(true));
                //return;
            //}

            //currentProto = Object::getProto(currentObject);
        //}
    //}
//}

ir CacheStub emits CacheIR {
    op InstanceOf(lhsId: ValueId, rhsId: ValueId, protoId: ObjectId) {
        assume CacheIR::useValueReg(lhsId) == CacheIR::allocateValueReg();
        assume CacheIR::useValueReg(rhsId) == CacheIR::allocateValueReg();
        assume CacheIR::useObjectReg(protoId) == CacheIR::allocateReg();

        emit CacheIR::GuardToObject(rhsId, protoId);
        emit CacheIR::LoadInstanceOfObjectResult(lhsId, protoId);
    }
}
