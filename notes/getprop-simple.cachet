// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;

    /* ... */

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = unsafe { Value::fromObjectUnchecked(object) };
        assume Value::isObject(value);
        assume unsafe { Value::toObjectUnchecked(value) } == object;
        value
    }
    unsafe fn fromObjectUnchecked(object: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = unsafe { Value::toObjectUnchecked(value) };
        assume unsafe { Value::fromObjectUnchecked(object) } == value;
        object
    }
    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
    fn shapeOf(object: Object) -> Shape {
        unsafe { Object::shapeOfUnchecked(heap, object) }
    }
    unsafe fn shapeOfUnchecked(heap: Heap, object: Object) -> Shape;

    fn toNativeObject(object: Object) -> NativeObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isNativeObject(class);
        unsafe { object as NativeObject }
    }
  
    fn getFixedSlot(object: Object, slot: Int32) -> Value {
        let nativeObject = Object::toNativeObject(object);
        NativeObject::getFixedSlot(nativeObject, slot)
    }
}

struct NativeObject <: Object;

impl NativeObject {
    fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert Shape::hasFixedSlot(shape, slot);
        unsafe { NativeObject::getFixedSlotUnchecked(heap, nativeObject, slot) }
    }
    unsafe fn getFixedSlotUnchecked(heap: Heap, nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
    fn classOf(shape: Shape) -> Class;

    fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
    fn isNativeObject(class: Class) -> Bool;
}

struct ValueReg;
struct Reg;

ir MASM {
    op BranchTestNotObject(valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        if !Value::isObject(value) {
            goto branch;
        }
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op BranchTestNotObjectShape(objectReg: Reg, shape: Shape, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        if Object::shapeOf(object) != shape {
            goto branch;
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);
}

struct ValueId;
struct ObjectId;

struct Int32Field;
struct ShapeField;

struct RegAlloc;

ir CacheIR emits MASM {
    op GuardToObject(valueId: ValueId, objectId: ObjectId, label failure: MASM) {
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);
        emit MASM::BranchTestNotObject(valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField, label failure: MASM) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let shape = CacheIR::readShapeField(shapeField);
        emit MASM::BranchTestNotObjectShape(objectReg, shape, failure);
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }

    var mut regAlloc: RegAlloc;

    fn allocateValueReg() -> ValueReg {
      unsafe { CacheIR::allocateValueRegUnchecked(CacheIR::regAlloc, out CacheIR::regAlloc) }
    }
    unsafe fn allocateValueRegUnchecked(regAlloc: RegAlloc, out regAllocAfter: RegAlloc)
      -> ValueReg;

    fn releaseValueReg(valueReg: ValueReg) {
      unsafe {
        CacheIR::releaseValueRegUnchecked(CacheIR::regAlloc, valueReg, out CacheIR::regAlloc)
      }
    }
    unsafe fn releaseValueRegUnchecked(
      regAlloc: RegAlloc,
      valueReg: ValueReg,
      out regAllocAfter: RegAlloc
    );

    fn allocateReg() -> Reg {
      unsafe { CacheIR::allocateRegUnchecked(CacheIR::regAlloc, out CacheIR::regAlloc) }
    }
    unsafe fn allocateRegUnchecked(regAlloc: RegAlloc, out regAllocAfter: RegAlloc) -> Reg;

    fn releaseReg(reg: Reg) {
      unsafe { CacheIR::releaseRegUnchecked(CacheIR::regAlloc, reg, out CacheIR::regAlloc) }
    }
    unsafe fn releaseRegUnchecked(regAlloc: RegAlloc, reg: Reg, out regAllocAfter: RegAlloc);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;
}
