// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

var zero: Int32;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;
    fn setType(value: Value, valueTy: ValueType);

    // ...

    fn isInt32(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Int32
    }

    fn fromInt32(int32: Int32) -> Value {
        let value = (unsafe { Value::fromInt32Unchecked(int32) });
        assume Value::isInt32(value);
        assume (unsafe { Value::toInt32Unchecked(value) }) == int32;
        value
    }

    unsafe fn fromInt32Unchecked(value: Int32) -> Value;

    fn toInt32(value: Value) -> Int32 {
        assert Value::isInt32(value);
        let int32 = (unsafe { Value::toInt32Unchecked(value) });
        assume (unsafe { Value::fromInt32Unchecked(int32) }) == value;
        int32
    }

    unsafe fn toInt32Unchecked(value: Value) -> Int32;

    fn isBool(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Bool
    }

    fn fromBool(bool: Bool) -> Value {
        let value = (unsafe { Value::fromBoolUnchecked(bool) });
        assume Value::isBool(value);
        assume (unsafe { Value::toBoolUnchecked(value) }) == bool;
        value
    }

    unsafe fn fromBoolUnchecked(value: Bool) -> Value;

    fn toBool(value: Value) -> Bool {
        assert Value::isBool(value);
        let bool = (unsafe { Value::toBoolUnchecked(value) });
        assume (unsafe { Value::fromBoolUnchecked(bool) }) == value;
        bool
    }

    unsafe fn toBoolUnchecked(value: Value) -> Bool;

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn fromObject(object: Object) -> Value {
        let value = (unsafe { Value::fromObjectUnchecked(object) });
        assume Value::isObject(value);
        assume (unsafe { Value::toObjectUnchecked(value) }) == object;
        value
    }

    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = (unsafe { Value::toObjectUnchecked(value) });
        assume (unsafe { Value::fromObjectUnchecked(object) }) == value;
        object
    }

    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

struct Reg;

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

enum Condition {
    Equal,
    NotEqual,
    Overflow,
}

ir MASM {
    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
      let value = MASM::getValue(valueReg);
      let valueIsInt32 = Value::isInt32(value);

      if condition == Condition::Equal {
        if valueIsInt32 {
          goto branch;
        }
      }

      if condition == Condition::NotEqual {
        if !valueIsInt32 {
          goto branch;
        }
      }
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
      let value = MASM::getValue(valueReg);
      MASM::setInt32(int32Reg, Value::toInt32(value)); 
    }

    op Mov(srcReg: Reg, dstReg: Reg) {
      MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op TagValue(valTy: ValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == ValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        }
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 + rhsInt32;
      
      assert condition == Condition::Overflow;
      if lhsInt32 > 0_i32 {
        if rhsInt32 > 0_i32 {
          if result < 0_i32 {
            goto branch;
          }
        }
      }

      if lhsInt32 < 0_i32 {
        if rhsInt32 < 0_i32 {
          if result > 0_i32 {
            goto branch;
          }
        }
      }

      MASM::setInt32(dstReg, result);
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);
}

struct ValueId;
struct Int32Id;

ir CacheIR emits MASM {
  op GuardToInt32(valueId: ValueId, int32Id: Int32Id, label failure: MASM) {
    let valueReg = CacheIR::useValueReg(valueId);
    let int32Reg = CacheIR::useInt32Reg(int32Id);
    emit MASM::BranchTestInt32(Condition::NotEqual, valueReg, failure);
    emit MASM::UnboxInt32(valueReg, int32Reg);
  }

  op AddInt32Result(lhsId: Int32Id, rhsId: Int32Id, label failure: MASM) {
    let lhsReg = CacheIR::useInt32Reg(lhsId);
    let rhsReg = CacheIR::useInt32Reg(rhsId);

    let scratchReg = CacheIR::allocateReg();
    emit MASM::Mov(rhsReg, scratchReg);
    emit MASM::BranchAdd32(Condition::Overflow, lhsReg, scratchReg, failure);
    emit MASM::TagValue(ValueType::Int32, scratchReg, CacheIR::outputReg);
    
    CacheIR::releaseReg(scratchReg); 
  }

  fn allocateReg() -> Reg;
  fn releaseReg(reg: Reg);

  fn allocateValueReg() -> ValueReg;
  fn releaseValueReg(valueReg: ValueReg);

  fn useValueReg(valueId: ValueId) -> ValueReg;
  fn useInt32Reg(int32Id: Int32Id) -> Reg;

  var outputReg: ValueReg;
}

ir CacheStub emits CacheIR {
    op Add(
        lhsValueId: ValueId,
        rhsValueId: ValueId,
        lhsInt32Id: Int32Id,
        rhsInt32Id: Int32Id,
        label failure: MASM,
    ) {
        emit CacheIR::GuardToInt32(lhsValueId, lhsInt32Id, failure);
        emit CacheIR::GuardToInt32(rhsValueId, rhsInt32Id, failure);
        emit CacheIR::AddInt32Result(lhsInt32Id, rhsInt32Id, failure);
    }
}
