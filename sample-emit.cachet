enum ValueType {
  Double,
  Int32,
  Boolean,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
  fn typeOf(value: Value) -> ValueType;

  /* ... */

  fn isObject(value: Value) -> Bool {
    Value::typeOf(value) == ValueType::Object
  }

  fn fromObject(object: Object) -> Value {
    let value = unsafe { Value::fromObjectUnchecked(Value) };
    assume Value::isObject(value);
    assume Value::toObjectUnchecked(value) == object;
    value
  }
  unsafe fn fromObjectUnchecked(value: Value) -> Object;

  fn toObject(value: Value) -> Object {
    assert Value::isObject(value);
    let object = unsafe { Value::toObjectUnchecked(value) };
    assume Value::fromObjectUnchecked(object) == value;
    object
  }
  unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
  read fn shapeOf(object: Object) -> Shape;

  read fn toNativeObject(object: Object) -> NativeObject {
    let shape = Object::shapeOf(object);
    let class = Shape::classOf(shape);
    assert Class::isNativeObject(class);
    unsafe { object as NativeObject }
  }
  
  read fn getFixedSlot(object: Object, slot: Int32) -> Value {
    let nativeObject = Object::toNativeObject(object);
    NativeObject::getFixedSlot(nativeObject, slot)
  }
}

struct NativeObject <: Object;

impl NativeObject {
  read fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
    let shape = Object::shapeOf(nativeObject);
    assert Shape::hasFixedSlot(shape, slot);
    unsafe { NativeObject::getFixedSlotUnchecked(nativeObject, slot) }
  }

  unsafe read fn getFixedSlotUnchecked(nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
  fn classOf(shape: Shape) -> Class;

  fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
  fn isNativeObject(class: Class) -> Bool;
}

struct ValueReg;

impl ValueReg {
  fn getValue(valueReg: ValueReg) -> Value;
  fn setValue(valueReg: ValueReg, value: Value);
}

impl Reg {
  fn getObject(reg: Reg) -> Object;
  fn setObject(reg: Reg, object: Object);
}

ir MASM {
  op branchTestNotObject(valueReg: ValueReg, label: Label) {
    let value = ValueReg::getValue(valueReg);
    if !Value::isObject(value) {
      goto label;
    }
  }

  op unboxObject(valueReg: ValueReg, objectReg: Reg) {
    let value = ValueReg::getValue(valueReg);
    Reg::setObject(objectReg, Value::toObject(value));
  }

  read op branchTestNotObjectShape(objectReg: Reg, shape: Shape, label: Label) {
    let object = Reg::getObject(objectReg);
    if Object::shapeOf(object) != shape {
      goto label;
    }
  }

  read op loadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
    let object = Reg::getObject(objectReg);
    ValueReg::setValue(outputReg, Object::getFixedSlot(object, slot));
  }
}

struct ValId;

impl ValId {
  fn toValueReg(valId: ValId) -> ValueReg;
}

struct ObjId;

impl ObjId {
  fn toReg(objId: ObjId) -> Reg;
}

struct Int32Field;

impl Int32Field {
  fn toInt32(int32Field: Int32Field) -> Int32;
}

struct ShapeField;

impl ShapeField {
  fn toShape(shapeField: ShapeField) -> Shape;
}

ir CacheIR emits MASM {
  op guardToObject(valId: ValId, objId: ObjId, failure: Label) {
    //object = Value::toObject(value);
    let val = ValId::toValueReg(valId);
    let obj = ObjId::toReg(objId);
    emit MASM::branchTestNotObject(val, failure);
    emit MASM::unboxObject(val, obj);
  }

  read op guardShape(objId: ObjId, shapeField: ShapeField, failure: Label) {
    //guard Object::shapeOf(object) == shape;
    let obj = ObjId::toReg(objId);
    let shape = ShapeField::toShape(shapeField);
    emit MASM::branchTestNotObjectShape(obj, shape, failure);
  }

  read op loadFixedSlotResult(objId: ObjId, slotField: Int32Field, output: ValueReg) {
    //fallible { Object::getFixedSlot(object, slot) }
    let obj = ObjId::toReg(objId);
    let slot = Int32Field::toInt32(slotField);
    emit MASM::loadObjectFixedSlot(obj, slot, output);
  }
}
