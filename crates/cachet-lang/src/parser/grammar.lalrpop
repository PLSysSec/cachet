// vim: set tw=99 ts=4 sts=4 sw=4 et:

// TODO(spinda): Fix block comments. Seems like the parser might be too greedy
// right now.

use std::str::FromStr;

use codespan::RawIndex;
use iterate::iterate;
use typed_index_collections::TiVec;

use crate::ast::*;

use crate::parser::ast::*;
use crate::parser::helpers::*;

grammar(file_id: FileId);

extern {
    // TODO(spinda): Collect user errors as we go and discharge them at the end. 
    type Error = UserParseError;
}

#[inline]
Attrs: Vec<Attr> =
    <attrs:Attr*> => attrs;

Attr: Attr =
    "#" "[" <path:Spanned<Path>> "]" => Attr { path };

pub Items: Vec<Spanned<Item>> = Spanned<Item>*;

Item: Item = {
    <enum_item:EnumItem> => Item::from(enum_item).into(),
    <struct_item:StructItem> => Item::from(struct_item).into(),
    <ir_item:IrItem> => Item::from(ir_item).into(),
    <impl_item:ImplItem> => Item::from(impl_item).into(),
    <global_var_item:GlobalVarItem> => Item::from(global_var_item).into(),
    <callable_item:CallableItem> => callable_item,
};

EnumItem: EnumItem =
    "enum" <ident:Spanned<Ident>> "{" <variants:EnumVariants> "}" => EnumItem { ident, variants };

EnumVariants: TiVec<VariantIndex, Spanned<Ident>> =
    <variants:Comma<Spanned<Ident>>> => variants.into();

StructItem: StructItem =
    "struct" <ident:Spanned<Ident>> <supertype:("<:" <Spanned<Path>>)?> <fields:StructFields> =>
        StructItem { ident, supertype, fields };

StructFields: TiVec<FieldIndex, Field> = {
    ";"  => TiVec::new(),
    "{" <fields:Comma<Field>> "}" => fields.into(),
};

Field: Field =
    <ident: Spanned<Ident>> ":" <type_: Spanned<Path>> => {
        Field { ident, type_ }
    };

IrItem: IrItem =
    "ir" <ident:Spanned<Ident>> <emits:("emits" <Spanned<Path>>)?>
    "{" <items:Spanned<Item>*> "}" =>
        IrItem { ident, emits, items };

ImplItem: ImplItem =
    "impl" <parent:Spanned<Path>> "{" <items:Spanned<Item>*> "}" => ImplItem { parent, items };

GlobalVarItem: GlobalVarItem =
    <attrs:Attrs>
    "var" <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> ";" =>
        GlobalVarItem { ident, attrs, is_mut: tags.mut_tag.is_some(), type_ };

#[inline]
VarTags: VarTags =
    <tags:Spanned<VarTag>*> =>? VarTags::reduce(tags.into_iter());

VarTag: VarTag =
    "mut" => VarTag::Mut;

CallableItem: Item =
    <attrs:Attrs>
    <tags:CallableTags> <kind:CallableKind> <ident:Spanned<Ident>>
    "(" <params:Comma<Param>> ")" <ret:("->" <Spanned<Path>>)?>
    <body:Spanned<CallableBody>> => {
        let callable_item = CallableItem {
            ident,
            attrs,
            is_unsafe: tags.unsafe_tag.is_some(),
            params,
            ret,
            body,
        };

        match kind {
            CallableKind::Fn => Item::Fn(callable_item),
            CallableKind::Op => Item::Op(callable_item),
        }
    };

#[inline]
CallableTags: CallableTags =
    <tags:Spanned<CallableTag>*> =>? CallableTags::reduce(tags.into_iter());

CallableTag: CallableTag = {
    "unsafe" => CallableTag::Unsafe,
};

CallableKind: CallableKind = {
    "fn" => CallableKind::Fn,
    "op" => CallableKind::Op,
};

CallableBody: Option<Block> = {
    ";" => None,
    <block:Block> => Some(block),
};

Param: Param = {
    <var_param:VarParam> => var_param.into(),
    <label_param:LabelParam> => label_param.into(),
};

#[inline]
ParamTags: ParamTags =
    <tags:Spanned<ParamTag>*> =>? ParamTags::reduce(tags.into_iter());

ParamTag: ParamTag = {
    "in" => ParamTag::In,
    "ref" => ParamTag::Ref,
    "out" => ParamTag::Out,
    <var_tag:VarTag> => var_tag.into(),
};

VarParam: VarParam =
    <tags:ParamTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> =>?
    {
        let kind = if tags.in_tag.is_some() {
            VarRefKind::In.into()
        } else if tags.ref_tag.is_some() {
            VarRefKind::Mut.into()
        } else if tags.out_tag.is_some() {
            VarRefKind::Out.into()
        } else {
            VarParamKind::Value { is_mut: tags.var_tags.mut_tag.is_some() }
        };

        Ok(VarParam { ident, kind, type_ })
    };

LabelParam: LabelParam =
    <tags:ParamTags> <label:Label> =>?
    {
        if let Some(span) = tags.in_tag {
            return Err(RawParseError::User {
                error: Spanned::new(span, "label parameters can't be in-references"),
            });
        }

        if let Some(span) = tags.var_tags.mut_tag {
            return Err(RawParseError::User {
                error: Spanned::new(span, "label parameters can't be mutable"),
            });
        }

        Ok(LabelParam { label, is_out_ref: tags.out_tag.is_some() })
    };

Label: Label =
    "label" <ident:Spanned<Ident>> ":" <ir:Spanned<Path>> => Label { ident, ir };

Arg: Arg = {
    <expr:PrecExpr> => {
        match expr.expr {
            Expr::Var(path) if !expr.is_grouped => {
                FreeVarOrLabelArg { path, is_out_ref: false }.into()
            }
            expr => expr.into(),
        }
    },
    "out" <path:Spanned<Path>> => FreeVarOrLabelArg { path, is_out_ref: true }.into(),
    "in" <path:Spanned<Path>> => FreeVarRefArg { path, kind: VarRefKind::In }.into(),
    "ref" <path:Spanned<Path>> => FreeVarRefArg { path, kind: VarRefKind::Mut }.into(),
    "out" <local_var:LocalVar> => local_var.into(),
    "out" <local_label:LocalLabel> => local_label.into(),
};

Call: Call =
    <target:Spanned<Path>> <args:Spanned<("(" <Comma<Spanned<Arg>>> ")")>> =>
        Call { target, args };

LocalVar: LocalVar =
    "let" <tags:VarTags> <ident:Spanned<Ident>> <type_:(":" <Spanned<Path>>)?> =>
        LocalVar { ident, is_mut: tags.mut_tag.is_some(), type_ };

LocalLabel: LocalLabel =
    "label" <ident:Spanned<Ident>> <ir:(":" <Spanned<Path>>)?> => LocalLabel { ident, ir };

Block: Block =
    "{" ";"* <block:BlockInner> "}" => block;

BlockInner: Block = {
    <stmts:BlockOrStmt*> <value:Expr> => Block { stmts, value: Some(value) }, 
    <mut stmts:BlockOrStmt*> <stmt:SemiStmt> => {
        stmts.push(stmt);
        Block { stmts, value: None }
    },
    => Block { stmts: vec![], value: None }, 
};

BlockOrStmt: Spanned<Stmt> = {
    <block:Spanned<KindedBlock>> => block.map(Stmt::from),
    <stmt:SemiStmt> => stmt
};

KindedBlock: KindedBlock = {
    <kind:BlockKind?> <block:Block> => KindedBlock {
        kind,
        block,
    },
};

BlockKind: BlockKind = {
    "unsafe" => BlockKind::Unsafe,
};

#[inline]
SemiStmt: Spanned<Stmt> =
    <stmt:Spanned<Stmt>> ";"* => stmt;

Stmt: Stmt = {
    <let_stmt:LetStmt> ";" => let_stmt.into(),
    <label_stmt:LabelStmt> ";" => label_stmt.into(),
    <if_stmt:IfStmt> => if_stmt.into(),
    <check_stmt:CheckStmt> ";" => check_stmt.into(),
    <goto_stmt:GotoStmt> ";" => goto_stmt.into(),
    <bind_stmt:BindStmt> ";" => bind_stmt.into(),
    <emit_stmt:EmitStmt> ";" => emit_stmt,
    <expr:Expr> ";" => expr.into(),
};

LetStmt: LetStmt =
    <lhs:LocalVar> "=" <rhs:Spanned<Expr>> => LetStmt { lhs, rhs };

LabelStmt: LabelStmt =
    <label:Label> => LabelStmt { label };

IfStmt: IfStmt =
    "if" <cond:Spanned<Expr>> <then:Block> <else_:("else" <ElseClause>)?> =>
        IfStmt { cond, then, else_ };

ElseClause: ElseClause = {
    <else_if:Box<IfStmt>> => else_if.into(),
    <else_block:Block> => else_block.into(),
}

CheckStmt: CheckStmt =
    <kind:CheckKind> <cond:Spanned<Expr>> => CheckStmt { kind, cond };

CheckKind: CheckKind = {
    "assert" => CheckKind::Assert,
    "assume" => CheckKind::Assume,
};

GotoStmt: GotoStmt =
    "goto" <label:Spanned<Path>> => GotoStmt { label };

BindStmt: BindStmt =
    "bind" <label:Spanned<Path>> => BindStmt { label };

EmitStmt: Stmt =
    "emit" <call:Call> => Stmt::Emit(call);

Expr: Expr = {
    <expr:PrecExpr> => expr.expr,
};

PrecExpr: PrecExpr = {
    // Note that this breaks out of the precedence chain: an expression of any
    // precedence level can be grouped inside parentheses.
    #[precedence(level = "0")]
    "(" <expr:Expr> ")" => PrecExpr::grouped(expr),

    #[precedence(level = "0")]
    "(" <block:KindedBlock> ")" => Expr::from(block).into(),

    #[precedence(level = "0")]
    <literal:Literal> => Expr::from(literal).into(),

    #[precedence(level = "0")]
    <path:Spanned<Path>> => Expr::from(path).into(),

    #[precedence(level = "0")]
    <call:Call> => Expr::Invoke(call).into(),

    #[precedence(level = "0")]
    <parent:Spanned<PrecExpr>> "." <field: Spanned<Ident>> => Expr::from(FieldAccessExpr {
        parent: parent.map(|parent| parent.expr),
        field,
    }).into(),

    #[precedence(level = "1")]
    <kind:Spanned<NegateKind>> <expr:Spanned<PrecExpr>> => {
        let expr_span = expr.span;
        match (kind.value, expr.value.expr) {
            // If we're applying arithmetic negation to a numeric literal, negate
            // the literal value directly.
            (NegateKind::Arith, Expr::Literal(Literal::Int32(n))) => {
                Expr::from(Literal::Int32(-n))
            }
            (NegateKind::Arith, Expr::Literal(Literal::Int64(n))) => {
                Expr::from(Literal::Int64(-n))
            }
            (_, expr) => {
                Expr::from(NegateExpr {
                    kind,
                    expr: Spanned::new(expr_span, expr)
                })
            }
        }
    }.into(),

    #[precedence(level = "2")]
    <expr:Spanned<PrecExpr>> "as" <type_:Spanned<Path>> => Expr::from(CastExpr {
        expr: expr.map(|expr| expr.expr),
        type_,
    }).into(),

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<MulArithBinOper>> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: oper.map(Into::into),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),

    #[precedence(level = "4")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<AddArithBinOper>> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: oper.map(Into::into),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),

    #[precedence(level = "5")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"<<">> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, BitwiseBinOper::Shl.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),

    #[precedence(level = "6")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"&">> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, BitwiseBinOper::And.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),

    #[precedence(level = "7")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"^">> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, BitwiseBinOper::Xor.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),

    #[precedence(level = "8")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"|">> <rhs:Spanned<PrecExpr>> =>
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, BitwiseBinOper::Or.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr)
        }).into(),
    
    #[precedence(level = "9")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<CompareBinOper>> <rhs:Spanned<PrecExpr>> =>? {
        if !lhs.value.is_grouped {
            if let Expr::BinOper(lhs) = &lhs.value.expr {
                if let BinOper::Compare(_) = lhs.oper.value {
                    return Err(RawParseError::User {
                        error: Spanned::new(oper.span, "comparison operators can't be chained"),
                    });
                }
            }
        }

        Ok(Expr::from(BinOperExpr {
            oper: oper.map(Into::into),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr),
        }).into())
    },

    #[precedence(level = "10")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"&&">> <rhs:Spanned<PrecExpr>> =>
    {
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, LogicalBinOper::And.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr),
        }).into()
    },

    #[precedence(level = "11")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <oper:Spanned<"||">> <rhs:Spanned<PrecExpr>> =>
    {
        Expr::from(BinOperExpr {
            oper: Spanned::new(oper.span, LogicalBinOper::Or.into()),
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr),
        }).into()
    },

    #[precedence(level = "12")]
    #[assoc(side = "right")]
    <lhs:Spanned<PrecExpr>> "=" <rhs:Spanned<PrecExpr>> =>? {
        match lhs.value.expr {
            Expr::Var(lhs) => Ok(Expr::from(AssignExpr {
                lhs: lhs,
                rhs: rhs.map(|rhs| rhs.expr),
            }).into()),
            _ => Err(RawParseError::User {
                error: Spanned::new(lhs.span, "can't assign to this expression"),
            }),
        }
    },
};

NegateKind: NegateKind = {
    "-" => NegateKind::Arith,
    "!" => NegateKind::Logical,
};

MulArithBinOper: ArithBinOper = {
  "*" => ArithBinOper::Mul,
  "/" => ArithBinOper::Div,
}

AddArithBinOper: ArithBinOper = {
  "+" => ArithBinOper::Add,
  "-" => ArithBinOper::Sub,
}

CompareBinOper: CompareBinOper = {
    "==" => CompareBinOper::Eq,
    "!=" => CompareBinOper::Neq,
    <oper:NumericCompareBinOper> => oper.into(),
};

NumericCompareBinOper: NumericCompareBinOper = {
    "<" => NumericCompareBinOper::Lt,
    ">" => NumericCompareBinOper::Gt,
    "<=" => NumericCompareBinOper::Lte,
    ">=" => NumericCompareBinOper::Gte,
};

// TODO(spinda): Support NaN literals and scientific notation.

Literal: Literal = {
    <n:UInt16Literal> => Literal::UInt16(n),
    <n:Int32Literal> => Literal::Int32(n),
    <n:Int64Literal> => Literal::Int64(n),
    <n:DoubleLiteral> => Literal::Double(n),
};

UInt16Literal: u16 =
    <digits:Spanned<r"[0-9]+_u16">> =>?
        u16::from_str(&digits.value[..digits.value.len() - 4])
            .map_err(|error| RawParseError::User {
                error: Spanned::new(digits.span, "number too large to fit in UInt16"),
            });

Int32Literal: i32 =
    <digits:Spanned<r"[0-9]+_i32">> =>?
        i32::from_str(&digits.value[..digits.value.len() - 4])
            .map_err(|error| RawParseError::User {
                error: Spanned::new(digits.span, "number too large to fit in Int32"),
            });

DoubleLiteral : f64 =
    <digits:Spanned<r"[0-9]+.[0-9]+">> =>?
        f64::from_str(digits.value)
            .map_err(|error| RawParseError::User {
                error: Spanned::new(digits.span, "number is not a valid double"),
            });

Int64Literal: i64 =
    <digits:Spanned<r"[0-9]+_i64">> =>?
        i64::from_str(&digits.value[..digits.value.len() - 4])
            .map_err(|error| RawParseError::User {
                error: Spanned::new(digits.span, "number too large to fit in Int64"),
            });

Ident: Ident =
    <name:r"[A-Za-z_][A-Za-z0-9_]*"> => Ident::from(name);

Path: Path =
    <segments:(<Ident> "::")*> <segment:Ident> => iterate![..segments, segment].collect();

Spanned<Rule>: Spanned<Rule> =
    <start: @L> <value: Rule> <end: @R> =>
        Spanned::new(Span::new(file_id, start as RawIndex..end as RawIndex), value);

Box<Rule>: Box<Rule> =
    <value: Rule> =>
        Box::new(value);

Comma<Rule>: Vec<Rule> =
    <mut xs:(<Rule> ",")*> <x:Rule?> => {
        xs.extend(x);
        xs
    };

match {
    // Skip whitespace.
    r"\s*" => {},
    // Skip line comments.
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip block comments.
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {},
    _
}
