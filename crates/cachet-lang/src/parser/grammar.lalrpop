// vim: set tw=99 ts=4 sts=4 sw=4 et:

// TODO(spinda): Make user parse errors accumulate as we go, returning a big
// `Option<...>` that gets unwrapped at the end if there are no pending errors.

use codespan::RawIndex;
use iterate::iterate;

use crate::ast::{Ident, Path, Span, Spanned};

use crate::parser::ast::*;
use crate::parser::helpers::*;

grammar;

extern {
    type Error = UserParseError;
}

pub Items: Vec<Spanned<Item>> = Spanned<Item>*;

Item: Item = {
    <enum_item:EnumItem> => Item::from(enum_item).into(),
    <struct_item:StructItem> => Item::from(struct_item).into(),
    <ir_item:IrItem> => Item::from(ir_item).into(),
    <impl_item:ImplItem> => Item::from(impl_item).into(),
    <global_var_item:GlobalVarItem> => Item::from(global_var_item).into(),
    <callable_item:CallableItem> => callable_item,
};

EnumItem: EnumItem =
    "enum" <ident:Spanned<Ident>> "{" <variants:Comma<Spanned<Ident>>> "}" =>
        EnumItem { ident, variants: variants.into() };

StructItem: StructItem =
    "struct" <ident:Spanned<Ident>> <supertype:("<:" <Spanned<Path>>)?> ";" =>
        StructItem { ident, supertype };

IrItem: IrItem =
    "ir" <ident:Spanned<Ident>> <emits:("emits" <Spanned<Path>>)?>
    "{" <items:Spanned<Item>*> "}" =>
        IrItem { ident, emits, items };

ImplItem: ImplItem =
    "impl" <parent:Spanned<Path>> "{" <items:Spanned<Item>*> "}" => ImplItem { parent, items };

GlobalVarItem: GlobalVarItem =
    "var" <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> ";" =>
        GlobalVarItem { ident, is_mut: tags.mut_tag.is_some(), type_ };

#[inline]
VarTags: VarTags =
    <tags:Spanned<VarTag>*> =>? VarTags::reduce(tags.into_iter());

VarTag: VarTag =
    "mut" => VarTag::Mut;

CallableItem: Item =
    <tags:CallableTags> <kind:CallableKind> <name:Spanned<Ident>>
    "(" <params:Comma<Spanned<Param>>> ")" <ret:("->" <Spanned<Path>>)?>
    <body:Spanned<CallableBody>> =>? {
        let is_unsafe = tags.unsafe_tag.is_some();

        Ok(match kind {
            CallableKind::Fn => {
                let (params, param_order) = catalog_params(params)?;

                FnItem {
                    name,
                    parent: Hole::empty(),
                    is_unsafe,
                    params,
                    param_order,
                    ret: Hole::from_option(ret),
                    body: body.map(Hole::from_option),
                }.into()
            },
            CallableKind::Op => {
                let (params, param_order) = catalog_params(params)?;

                if let Some(ret) = ret {
                    return Err(ParseError::User {
                        error: Spanned::new(ret.span(), "`op` items can't return a value"),
                    });
                }

                let body_span = body.span();
                let body = match body.value {
                    Some(body) => Spanned::new(body_span, Hole::full(body)),
                    None => return Err(ParseError::User {
                        error: Spanned::new(body_span, "`op` items must have a body"),
                    }),
                };

                OpItem {
                    name,
                    parent: Hole::empty(),
                    is_unsafe,
                    params,
                    param_order,
                    ret: Hole::empty(),
                    body,
                }.into()
            }
        })
    };

#[inline]
CallableTags: CallableTags =
    <tags:Spanned<CallableTag>*> =>? CallableTags::reduce(tags.into_iter());

CallableTag: CallableTag = {
    "unsafe" => CallableTag::Unsafe,
};

CallableKind: CallableKind = {
    "fn" => CallableKind::Fn,
    "op" => CallableKind::Op,
};

Param: Param = {
    <var_param:VarParam> => var_param.into(),
    <out_var_param:OutVarParam> => out_var_param.into(),
    "label" <label:Spanned<Ident>> => Param::Label(label),
};

VarParam: ParserVarParam =
    <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> =>
        VarParam { ident, is_mut: tags.mut_tag.is_some(), type_ };

OutVarParam: ParserOutVarParam =
    "out" <ident:Spanned<Ident>> ":" <type_: Spanned<Path>> => OutVarParam { ident, type_ };

Call<C, Arg>: ParserCall<C> =
    <target:Spanned<Path>> <args:Spanned<("(" <Comma<Spanned<Arg>>> ")")>> =>
        Call { target, args };

#[inline]
FnCallConfig: FnCallConfig = => FnCallConfig;
#[inline]
OpCallConfig: OpCallConfig = => OpCallConfig;

FnArg: ParserFnArg = {
    <expr:RawBlockOrExpr> => {
        match expr.expr {
            // Arguments that look like `bar` in `foo(bar)` could be either a
            // variable expression argument or a label argument. They will have
            // to be disambiguated during name resolution.
            Expr::Var(var_expr) if !expr.is_grouped => Arg::Label(var_expr.var),
            expr => expr.into(),
        }
    },
    <out_var:OutVar> => out_var.into(),
};

OpArg: ParserOpArg =
    <fn_arg:Spanned<FnArg>> =>? match fn_arg.value {
        Arg::Expr(expr) => Ok(expr.into()),
        Arg::Label(label) => Ok(Arg::Label(label)),
        Arg::OutVar(_, _) => Err(ParseError::User {
            error: Spanned::new(fn_arg.span(), "ops can't have out-parameters"),
        }),
    };

OutVar: ParserOutVar = {
    "out" <out_var_path:Spanned<Path>> => OutVar::Out(out_var_path),
    "out" <out_let_var:LocalVar> => OutVar::OutLet(out_let_var),
};

CallableBody: Option<ParserBody> = {
    ";" => None,
    <block:Block> => Some(Body {
        locals: Hole::empty(),
        block,
    }),
};

Block: ParserBlock = {
    "{" <stmts:Stmts> <value:Expr?> "}" => Block { stmts, value }, 
    "{" <value:BlockOrExpr?> "}" => Block { stmts: vec![], value },

    "{" <stmts_block:StmtsBlock> "}" => {
        let (stmts, block) = stmts_block;
        Block { stmts, value: Some(block.into()) }
    },
    "{" <stmts_block:StmtsBlock> <value:Expr> "}" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        Block { stmts, value: Some(value) }
    },
};

Stmts: Vec<ParserStmt> = {
    <stmt:Stmt> => vec![stmt],
    <stmts:Stmts> ";" => stmts,
    <mut stmts:Stmts> <stmt:Stmt> => {
        stmts.push(stmt);
        stmts
    },

    <block:Block> ";" => vec![block.into()],
    <block:Block> <stmt:Stmt> => vec![block.into(), stmt],

    <stmts_block:StmtsBlock> ";" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        stmts
    },
    <stmts_block:StmtsBlock> <stmt:Stmt> => {
        let (mut stmts, block) = stmts_block;
        stmts.extend([block.into(), stmt]);
        stmts
    },
};

StmtsBlock: (Vec<ParserStmt>, ParserBlock) = {
    <stmts:Stmts> <block:Block> => (stmts, block),
    <prev_block:Block> <block:Block> => (vec![prev_block.into()], block),
    <stmts_block:StmtsBlock> <block:Block> => {
        let (mut stmts, prev_block) = stmts_block;
        stmts.push(prev_block.into());
        (stmts, block)
    },
};

Stmt: ParserStmt = {
    <let_stmt:LetStmt> => let_stmt.into(),
    <if_stmt:IfStmt> => if_stmt.into(),
    <check_stmt:CheckStmt> => check_stmt.into(),
    <goto_stmt:GotoStmt> => goto_stmt.into(),
    <emit_stmt:EmitStmt> => emit_stmt.into(),
    <expr:Expr> ";" => expr.into(),
};

LetStmt: ParserLetStmt =
    <lhs:LocalVar> "=" <rhs:Spanned<BlockOrExpr>> ";" => LetStmt { lhs, rhs };

LocalVar: ParserLocalVar =
    "let" <tags:VarTags> <ident:Spanned<Ident>> <type_:(":" <Spanned<Path>>)?> =>
        LocalVar {
            ident,
            is_mut: tags.mut_tag.is_some(),
            type_: Hole::from_option(type_),
        };

IfStmt: ParserIfStmt =
    "if" <cond:Spanned<BlockOrExpr>> <then:Block> <else_:("else" <Block>)?> =>
        IfStmt { cond, then, else_ };

CheckStmt: ParserCheckStmt =
    <kind:CheckStmtKind> <cond:Spanned<BlockOrExpr>> ";" => CheckStmt { kind, cond };

CheckStmtKind: CheckStmtKind = {
    "assert" => CheckStmtKind::Assert,
    "assume" => CheckStmtKind::Assume,
};

GotoStmt: ParserGotoStmt =
    "goto" <label:Spanned<Path>> ";" => GotoStmt { label };

EmitStmt: ParserEmitStmt =
    "emit" <call:Call<OpCallConfig, OpArg>> => call;

#[inline]
Expr: ParserExpr = Expr0;

#[inline]
BlockOrExpr: ParserExpr = BlockOrExpr0;

#[inline]
RawExpr: MaybeGrouped = RawExpr0;

#[inline]
RawBlockOrExpr: MaybeGrouped = RawBlockOrExpr0;

Expr0: ParserExpr =
    <expr:RawExpr0> => expr.expr;

BlockOrExpr0: ParserExpr =
    <expr:RawBlockOrExpr0> => expr.expr;

RawExpr0: MaybeGrouped = {
    <assign_expr:AssignExpr> => MaybeGrouped::ungrouped(assign_expr.into()),
    RawExpr1,
};

RawBlockOrExpr0: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr0,
};

Expr1: ParserExpr =
    <expr:RawExpr1> => expr.expr;

BlockOrExpr1: ParserExpr =
    <expr:RawBlockOrExpr1> => expr.expr;

RawExpr1: MaybeGrouped = {
    <compare_expr:CompareExpr> => MaybeGrouped::ungrouped(compare_expr.into()),
    RawExpr2,
};

RawBlockOrExpr1: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr1,
};

Expr2: ParserExpr =
    <expr:RawExpr2> => expr.expr;

BlockOrExpr2: ParserExpr =
    <expr:RawBlockOrExpr2> => expr.expr;

RawExpr2: MaybeGrouped = {
    <cast_expr:CastExpr> => MaybeGrouped::ungrouped(cast_expr.into()),
    RawExpr3,
};

RawBlockOrExpr2: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr2,
};

Expr3: ParserExpr =
    <expr:RawExpr3> => expr.expr;

BlockOrExpr3: ParserExpr =
    <expr:RawBlockOrExpr3> => expr.expr;

RawExpr3: MaybeGrouped = {
    "(" <expr:BlockOrExpr0> ")" => MaybeGrouped::grouped(expr),
    <block_expr:BlockExpr> => MaybeGrouped::ungrouped(block_expr.into()),
    <var_or_call_expr:VarOrCallExpr> => MaybeGrouped::ungrouped(var_or_call_expr),
    <negate_expr:NegateExpr> => MaybeGrouped::ungrouped(negate_expr.into()),
};

RawBlockOrExpr3: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr3,
};

BlockExpr: ParserBlockExpr =
    <kind:BlockExprKind> <block:Block> => BlockExpr {
        kind: Some(kind),
        block,
    };

BlockExprKind: BlockExprKind = {
    "unsafe" => BlockExprKind::Unsafe,
};

VarOrCallExpr: ParserExpr = {
    <call_expr:CallExpr> => call_expr.into(),
    <var:Spanned<Path>> => VarExpr { var, type_: Hole::empty() }.into(),
};

CallExpr: ParserCallExpr = 
    <call:Call<FnCallConfig, FnArg>> => CallExpr {
        call,
        type_: Hole::empty(),
    };

NegateExpr: ParserNegateExpr =
    <kind:Spanned<NegateExprKind>> <expr:Spanned<BlockOrExpr3>> => NegateExpr { kind, expr };

NegateExprKind: NegateExprKind = {
    "-" => NegateExprKind::Arithmetic,
    "!" => NegateExprKind::Logical,
};

CastExpr: ParserCastExpr =
    <expr:Spanned<BlockOrExpr2>> "as" <type_:Spanned<Path>> => CastExpr { expr, type_ };

CompareExpr: ParserCompareExpr =
    <lhs:Spanned<RawBlockOrExpr1>> <kind:Spanned<CompareExprKind>> <rhs:Spanned<BlockOrExpr2>> =>?
    {
        if !lhs.value.is_grouped {
            if let Expr::Compare(_) = lhs.value.expr {
                return Err(ParseError::User {
                    error: Spanned::new(kind.span(), "comparison operators can't be chained"),
                });
            }
        }

        Ok(CompareExpr {
            kind,
            lhs: lhs.map(|lhs| lhs.expr),
            rhs
        })
    };

CompareExprKind: CompareExprKind = {
    "==" => CompareExprKind::Eq,
    "!=" => CompareExprKind::Neq,
    "<=" => CompareExprKind::Lte,
    ">=" => CompareExprKind::Gte,
    "<" => CompareExprKind::Lt,
    ">" => CompareExprKind::Gt,
};

AssignExpr: ParserAssignExpr =
    <lhs:Spanned<BlockOrExpr1>> "=" <rhs: Spanned<BlockOrExpr0>> =>? {
        match lhs.value {
            Expr::Var(lhs) => Ok(AssignExpr { lhs: lhs.var, rhs }),
            _ => Err(ParseError::User {
                error: Spanned::new(lhs.span(), "can't assign to this expression"),
            }),
        }
    };

Ident: Ident =
    <name:r"[A-Za-z_][A-Za-z0-9_]*"> => Ident::from(name);

Path: Path =
    <segments:(<Ident> "::")*> <segment:Ident> => iterate![..segments, segment].collect();

Spanned<Rule>: Spanned<Rule> =
    <start: @L> <value: Rule> <end: @R> =>
        Spanned::new(Span::new(start as RawIndex, end as RawIndex), value);

Comma<Rule>: Vec<Rule> =
    <mut xs:(<Rule> ",")*> <x:Rule?> => {
        xs.extend(x);
        xs
    };

match {
    // Skip whitespace.
    r"\s*" => {},
    // Skip line comments.
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip block comments.
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {},
    _
}
