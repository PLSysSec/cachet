// vim: set tw=99 ts=4 sts=4 sw=4 et:

use codespan::RawIndex;
use iterate::iterate;

use crate::ast::*;

use crate::parser::ast::*;
use crate::parser::helpers::*;

grammar;

extern {
    // TODO(spinda): Collect user errors as we go and discharge them at the end. 
    type Error = UserParseError;
}

pub Items: Vec<Spanned<Item>> = Spanned<Item>*;

Item: Item = {
    <enum_item:EnumItem> => Item::from(enum_item).into(),
    <struct_item:StructItem> => Item::from(struct_item).into(),
    <ir_item:IrItem> => Item::from(ir_item).into(),
    <impl_item:ImplItem> => Item::from(impl_item).into(),
    <global_var_item:GlobalVarItem> => Item::from(global_var_item).into(),
    <callable_item:CallableItem> => callable_item,
};

EnumItem: EnumItem =
    "enum" <ident:Spanned<Ident>> "{" <variants:Comma<Spanned<Ident>>> "}" =>
        EnumItem { ident, variants: variants.into() };

StructItem: StructItem =
    "struct" <ident:Spanned<Ident>> <supertype:("<:" <Spanned<Path>>)?> ";" =>
        StructItem { ident, supertype };

IrItem: IrItem =
    "ir" <ident:Spanned<Ident>> <emits:("emits" <Spanned<Path>>)?>
    "{" <items:Spanned<Item>*> "}" =>
        IrItem { ident, emits, items };

ImplItem: ImplItem =
    "impl" <parent:Spanned<Path>> "{" <items:Spanned<Item>*> "}" => ImplItem { parent, items };

GlobalVarItem: GlobalVarItem =
    "var" <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> ";" =>
        GlobalVarItem { ident, is_mut: tags.mut_tag.is_some(), type_ };

#[inline]
VarTags: VarTags =
    <tags:Spanned<VarTag>*> =>? VarTags::reduce(tags.into_iter());

VarTag: VarTag =
    "mut" => VarTag::Mut;

CallableItem: Item =
    <tags:CallableTags> <kind:CallableKind> <ident:Spanned<Ident>>
    "(" <params:Comma<Param>> ")" <ret:("->" <Spanned<Path>>)?>
    <body:Spanned<CallableBody>> => {
        let callable_item = CallableItem {
            ident,
            is_unsafe: tags.unsafe_tag.is_some(),
            params,
            ret,
            body,
        };

        match kind {
            CallableKind::Fn => Item::Fn(callable_item),
            CallableKind::Op => Item::Op(callable_item),
        }
    };

#[inline]
CallableTags: CallableTags =
    <tags:Spanned<CallableTag>*> =>? CallableTags::reduce(tags.into_iter());

CallableTag: CallableTag = {
    "unsafe" => CallableTag::Unsafe,
};

CallableKind: CallableKind = {
    "fn" => CallableKind::Fn,
    "op" => CallableKind::Op,
};

CallableBody: Option<Block> = {
    ";" => None,
    <block:Block> => Some(block),
};

Param: Param = {
    <var_param:VarParam> => var_param.into(),
    <out_var_param:OutVarParam> => out_var_param.into(),
    "label" <label:Spanned<Ident>> => Param::Label(label),
};

VarParam: VarParam =
    <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> =>
        VarParam { ident, is_mut: tags.mut_tag.is_some(), type_ };

OutVarParam: OutVarParam =
    "out" <ident:Spanned<Ident>> ":" <type_: Spanned<Path>> => OutVarParam { ident, type_ };

Arg: Arg = {
    <expr:RawBlockOrExpr> => {
        match expr.expr {
            Expr::Var(path) if !expr.is_grouped => Arg::VarExprOrLabel(path),
            expr => expr.into(),
        }
    },
    "out" <out_var_path:Spanned<Path>> => OutVar::Out(out_var_path).into(),
    "out" <out_let_var:LocalVar> => OutVar::OutLet(out_let_var).into(),
};

Call: Call =
    <target:Spanned<Path>> <args:Spanned<("(" <Comma<Spanned<Arg>>> ")")>> =>
        Call { target, args };

LocalVar: LocalVar =
    "let" <tags:VarTags> <ident:Spanned<Ident>> <type_:(":" <Spanned<Path>>)?> =>
        LocalVar { ident, is_mut: tags.mut_tag.is_some(), type_ };

Block: Block = {
    "{" <stmts:Stmts> <value:Expr?> "}" => Block { stmts, value }, 
    "{" <value:BlockOrExpr?> "}" => Block { stmts: vec![], value },

    "{" <stmts_block:StmtsBlock> "}" => {
        let (stmts, block) = stmts_block;
        Block { stmts, value: Some(block.into()) }
    },
    "{" <stmts_block:StmtsBlock> <value:Expr> "}" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        Block { stmts, value: Some(value) }
    },
};

Stmts: Vec<Stmt> = {
    <stmt:Stmt> => vec![stmt],
    <stmts:Stmts> ";" => stmts,
    <mut stmts:Stmts> <stmt:Stmt> => {
        stmts.push(stmt);
        stmts
    },

    <block:Block> ";" => vec![block.into()],
    <block:Block> <stmt:Stmt> => vec![block.into(), stmt],

    <stmts_block:StmtsBlock> ";" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        stmts
    },
    <stmts_block:StmtsBlock> <stmt:Stmt> => {
        let (mut stmts, block) = stmts_block;
        stmts.extend([block.into(), stmt]);
        stmts
    },
};

StmtsBlock: (Vec<Stmt>, Block) = {
    <stmts:Stmts> <block:Block> => (stmts, block),
    <prev_block:Block> <block:Block> => (vec![prev_block.into()], block),
    <stmts_block:StmtsBlock> <block:Block> => {
        let (mut stmts, prev_block) = stmts_block;
        stmts.push(prev_block.into());
        (stmts, block)
    },
};

Stmt: Stmt = {
    <let_stmt:LetStmt> => let_stmt.into(),
    <if_stmt:IfStmt> => if_stmt.into(),
    <check_stmt:CheckStmt> => check_stmt.into(),
    <goto_stmt:GotoStmt> => goto_stmt.into(),
    <emit_stmt:EmitStmt> => emit_stmt,
    <expr:Expr> ";" => expr.into(),
};

LetStmt: LetStmt =
    <lhs:LocalVar> "=" <rhs:Spanned<BlockOrExpr>> ";" => LetStmt { lhs, rhs };

IfStmt: IfStmt =
    "if" <cond:Spanned<BlockOrExpr>> <then:Block> <else_:("else" <Block>)?> =>
        IfStmt { cond, then, else_ };

CheckStmt: CheckStmt =
    <kind:CheckKind> <cond:Spanned<BlockOrExpr>> ";" => CheckStmt { kind, cond };

CheckKind: CheckKind = {
    "assert" => CheckKind::Assert,
    "assume" => CheckKind::Assume,
};

GotoStmt: GotoStmt =
    "goto" <label:Spanned<Path>> ";" => GotoStmt { label };

EmitStmt: Stmt =
    "emit" <call:Call> => Stmt::Emit(call);

#[inline]
Expr: Expr = Expr0;

#[inline]
BlockOrExpr: Expr = BlockOrExpr0;

#[inline]
RawExpr: MaybeGrouped = RawExpr0;

#[inline]
RawBlockOrExpr: MaybeGrouped = RawBlockOrExpr0;

Expr0: Expr =
    <expr:RawExpr0> => expr.expr;

BlockOrExpr0: Expr =
    <expr:RawBlockOrExpr0> => expr.expr;

RawExpr0: MaybeGrouped = {
    <assign_expr:AssignExpr> => MaybeGrouped::ungrouped(assign_expr.into()),
    RawExpr1,
};

RawBlockOrExpr0: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr0,
};

Expr1: Expr =
    <expr:RawExpr1> => expr.expr;

BlockOrExpr1: Expr =
    <expr:RawBlockOrExpr1> => expr.expr;

RawExpr1: MaybeGrouped = {
    <compare_expr:CompareExpr> => MaybeGrouped::ungrouped(compare_expr.into()),
    RawExpr2,
};

RawBlockOrExpr1: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr1,
};

Expr2: Expr =
    <expr:RawExpr2> => expr.expr;

BlockOrExpr2: Expr =
    <expr:RawBlockOrExpr2> => expr.expr;

RawExpr2: MaybeGrouped = {
    <cast_expr:CastExpr> => MaybeGrouped::ungrouped(cast_expr.into()),
    RawExpr3,
};

RawBlockOrExpr2: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr2,
};

Expr3: Expr =
    <expr:RawExpr3> => expr.expr;

BlockOrExpr3: Expr =
    <expr:RawBlockOrExpr3> => expr.expr;

RawExpr3: MaybeGrouped = {
    "(" <expr:BlockOrExpr0> ")" => MaybeGrouped::grouped(expr),
    <block_expr:BlockExpr> => MaybeGrouped::ungrouped(block_expr.into()),
    <call:Call> => MaybeGrouped::ungrouped(Expr::Invoke(call)),
    <path:Spanned<Path>> => MaybeGrouped::ungrouped(path.into()),
    <negate_expr:NegateExpr> => MaybeGrouped::ungrouped(negate_expr.into()),
};

RawBlockOrExpr3: MaybeGrouped = {
    <block:Block> => MaybeGrouped::ungrouped(block.into()),
    RawExpr3,
};

BlockExpr: BlockExpr =
    <kind:BlockKind> <block:Block> => BlockExpr {
        kind: Some(kind),
        block,
    };

BlockKind: BlockKind = {
    "unsafe" => BlockKind::Unsafe,
};

NegateExpr: NegateExpr =
    <kind:Spanned<NegateKind>> <expr:Spanned<BlockOrExpr3>> => NegateExpr { kind, expr };

NegateKind: NegateKind = {
    "-" => NegateKind::Arithmetic,
    "!" => NegateKind::Logical,
};

CastExpr: CastExpr =
    <expr:Spanned<BlockOrExpr2>> "as" <type_:Spanned<Path>> => CastExpr { expr, type_ };

CompareExpr: CompareExpr =
    <lhs:Spanned<RawBlockOrExpr1>> <kind:Spanned<CompareKind>> <rhs:Spanned<BlockOrExpr2>> =>?
    {
        if !lhs.value.is_grouped {
            if let Expr::Compare(_) = lhs.value.expr {
                return Err(ParseError::User {
                    error: Spanned::new(kind.span, "comparison operators can't be chained"),
                });
            }
        }

        Ok(CompareExpr {
            kind,
            lhs: lhs.map(|lhs| lhs.expr),
            rhs
        })
    };

CompareKind: CompareKind = {
    "==" => CompareKind::Eq,
    "!=" => CompareKind::Neq,
    "<=" => CompareKind::Lte,
    ">=" => CompareKind::Gte,
    "<" => CompareKind::Lt,
    ">" => CompareKind::Gt,
};

AssignExpr: AssignExpr =
    <lhs:Spanned<BlockOrExpr1>> "=" <rhs: Spanned<BlockOrExpr0>> =>? {
        match lhs.value {
            Expr::Var(lhs) => Ok(AssignExpr { lhs, rhs }),
            _ => Err(ParseError::User {
                error: Spanned::new(lhs.span, "can't assign to this expression"),
            }),
        }
    };

Ident: Ident =
    <name:r"[A-Za-z_][A-Za-z0-9_]*"> => Ident::from(name);

Path: Path =
    <segments:(<Ident> "::")*> <segment:Ident> => iterate![..segments, segment].collect();

Spanned<Rule>: Spanned<Rule> =
    <start: @L> <value: Rule> <end: @R> =>
        Spanned::new(Span::new(start as RawIndex, end as RawIndex), value);

Comma<Rule>: Vec<Rule> =
    <mut xs:(<Rule> ",")*> <x:Rule?> => {
        xs.extend(x);
        xs
    };

match {
    // Skip whitespace.
    r"\s*" => {},
    // Skip line comments.
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip block comments.
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {},
    _
}
