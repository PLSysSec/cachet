// vim: set tw=99 ts=4 sts=4 sw=4 et:

// TODO(spinda): Fix block comments. Seems like the parser might be too greedy
// right now.

use std::str::FromStr;

use codespan::RawIndex;
use iterate::iterate;

use crate::ast::*;

use crate::parser::ast::*;
use crate::parser::helpers::*;

grammar;

extern {
    // TODO(spinda): Collect user errors as we go and discharge them at the end. 
    type Error = UserParseError;
}

pub Items: Vec<Spanned<Item>> = Spanned<Item>*;

Item: Item = {
    <enum_item:EnumItem> => Item::from(enum_item).into(),
    <struct_item:StructItem> => Item::from(struct_item).into(),
    <ir_item:IrItem> => Item::from(ir_item).into(),
    <impl_item:ImplItem> => Item::from(impl_item).into(),
    <global_var_item:GlobalVarItem> => Item::from(global_var_item).into(),
    <callable_item:CallableItem> => callable_item,
};

EnumItem: EnumItem =
    "enum" <ident:Spanned<Ident>> "{" <variants:Comma<Spanned<Ident>>> "}" =>
        EnumItem { ident, variants: variants.into() };

StructItem: StructItem =
    "struct" <ident:Spanned<Ident>> <supertype:("<:" <Spanned<Path>>)?> ";" =>
        StructItem { ident, supertype };

IrItem: IrItem =
    "ir" <ident:Spanned<Ident>> <emits:("emits" <Spanned<Path>>)?>
    "{" <items:Spanned<Item>*> "}" =>
        IrItem { ident, emits, items };

ImplItem: ImplItem =
    "impl" <parent:Spanned<Path>> "{" <items:Spanned<Item>*> "}" => ImplItem { parent, items };

GlobalVarItem: GlobalVarItem =
    "var" <tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> ";" =>
        GlobalVarItem { ident, is_mut: tags.mut_tag.is_some(), type_ };

#[inline]
VarTags: VarTags =
    <tags:Spanned<VarTag>*> =>? VarTags::reduce(tags.into_iter());

VarTag: VarTag =
    "mut" => VarTag::Mut;

CallableItem: Item =
    <tags:CallableTags> <kind:CallableKind> <ident:Spanned<Ident>>
    "(" <params:Comma<Param>> ")" <ret:("->" <Spanned<Path>>)?>
    <body:Spanned<CallableBody>> => {
        let callable_item = CallableItem {
            ident,
            is_unsafe: tags.unsafe_tag.is_some(),
            params,
            ret,
            body,
        };

        match kind {
            CallableKind::Fn => Item::Fn(callable_item),
            CallableKind::Op => Item::Op(callable_item),
        }
    };

#[inline]
CallableTags: CallableTags =
    <tags:Spanned<CallableTag>*> =>? CallableTags::reduce(tags.into_iter());

CallableTag: CallableTag = {
    "unsafe" => CallableTag::Unsafe,
};

CallableKind: CallableKind = {
    "fn" => CallableKind::Fn,
    "op" => CallableKind::Op,
};

CallableBody: Option<Block> = {
    ";" => None,
    <block:Block> => Some(block),
};

Param: Param = {
    <var_param:VarParam> => var_param.into(),
    <label_param:LabelParam> => label_param.into(),
};

#[inline]
ParamTags: ParamTags =
    <tags:Spanned<ParamTag>*> =>? ParamTags::reduce(tags.into_iter());

ParamTag: ParamTag =
    "out" => ParamTag::Out;

VarParam: VarParam =
    <param_tags:ParamTags> <var_tags:VarTags> <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> =>?
    {
        let kind = match param_tags.out_tag {
            None => match var_tags.mut_tag {
                None => VarParamKind::In,
                Some(_) => VarParamKind::Mut,
            },
            Some(_) => match var_tags.mut_tag {
                None => VarParamKind::Out,
                Some(mut_tag_span) => return Err(ParseError::User {
                    error: Spanned::new(
                        mut_tag_span,
                        "`mut` is irrelevant for out-parameters"
                    ),
                }),
            },
        };

        Ok(VarParam { ident, kind, type_ })
    };

LabelParam: LabelParam =
    <tags:ParamTags> <label:Label> => LabelParam { label, is_out: tags.out_tag.is_some() };

Label: Label =
    "label" <ident:Spanned<Ident>> ":" <ir:Spanned<Path>> => Label { ident, ir };

Arg: Arg = {
    <expr:PrecExpr> => {
        match expr.expr {
            Expr::Var(path) if !expr.is_grouped => {
                FreeVarOrLabelArg { path, is_out: false }.into()
            }
            expr => expr.into(),
        }
    },
    "out" <path:Spanned<Path>> => FreeVarOrLabelArg { path, is_out: true }.into(),
    "out" <local_var:LocalVar> => local_var.into(),
    "out" <local_label:LocalLabel> => local_label.into(),
};

Call: Call =
    <target:Spanned<Path>> <args:Spanned<("(" <Comma<Spanned<Arg>>> ")")>> =>
        Call { target, args };

LocalVar: LocalVar =
    "let" <tags:VarTags> <ident:Spanned<Ident>> <type_:(":" <Spanned<Path>>)?> =>
        LocalVar { ident, is_mut: tags.mut_tag.is_some(), type_ };

LocalLabel: LocalLabel =
    "label" <ident:Spanned<Ident>> <ir:(":" <Spanned<Path>>)?> => LocalLabel { ident, ir };


Block: Block = {
    "{" <stmts:BlockOrStmt*> <value:Expr> "}" => Block { stmts, value: Some(value) }, 
    "{" <stmts:BlockOrStmt*> <stmt: Stmt> "}" => Block { stmts, value: None}, 
    "{" "}" => Block { stmts: vec![], value: None}, 
};

KindedBlock: BlockExpr = {
    <kind:BlockKind?> <block:Block> => BlockExpr {
        kind,
        block,
    },
}

BlockOrStmt: Stmt = {
    <block: KindedBlock> => Expr::from(block).into(),
    <stmt: Stmt> => stmt
}

Stmt: Stmt = {
    <let_stmt:LetStmt> ";" => let_stmt.into(),
    <label_stmt:LabelStmt> ";" => label_stmt.into(),
    <if_stmt:IfStmt> => if_stmt.into(),
    <check_stmt:CheckStmt> ";" => check_stmt.into(),
    <goto_stmt:GotoStmt> ";" => goto_stmt.into(),
    <bind_stmt:BindStmt> ";" => bind_stmt.into(),
    <emit_stmt:EmitStmt> ";" => emit_stmt,
    <expr:Expr> ";" => expr.into(),
};

LetStmt: LetStmt =
    <lhs:LocalVar> "=" <rhs:Spanned<Expr>> => LetStmt { lhs, rhs };

LabelStmt: LabelStmt =
    <label:Label> => LabelStmt { label };

IfStmt: IfStmt =
    "if" <cond:Spanned<Expr>> <then:Block> <else_:("else" <ElseClause>)?> =>
        IfStmt { cond, then, else_ };

ElseClause: ElseClause = {
    <else_if:Box<IfStmt>> => else_if.into(),
    <else_block:Block> => else_block.into(),
}

CheckStmt: CheckStmt =
    <kind:CheckKind> <cond:Spanned<Expr>> => CheckStmt { kind, cond };

CheckKind: CheckKind = {
    "assert" => CheckKind::Assert,
    "assume" => CheckKind::Assume,
};

GotoStmt: GotoStmt =
    "goto" <label:Spanned<Path>> => GotoStmt { label };

BindStmt: BindStmt =
    "bind" <label:Spanned<Path>> => BindStmt { label };

EmitStmt: Stmt =
    "emit" <call:Call> => Stmt::Emit(call);

Expr: Expr = {
    <expr:PrecExpr> => expr.expr,
};

PrecExpr: PrecExpr = {
    #[precedence(level = "0")]
    // Note that this breaks out of the precedence chain: an expression of any
    // precedence level can be grouped inside parentheses.
    "(" <expr:Expr> ")" => PrecExpr::grouped(expr),

    #[precedence(level = "0")]
    <block:KindedBlock> => Expr::from(block).into(),

    #[precedence(level = "0")]
    <literal:Literal> => Expr::from(literal).into(),

    #[precedence(level = "0")]
    <path:Spanned<Path>> => Expr::from(path).into(),

    #[precedence(level = "0")]
    <call:Call> => Expr::Invoke(call).into(),

    #[precedence(level = "0")]
    <kind:Spanned<NegateKind>> <expr:Spanned<PrecExpr>> => {
        let expr_span = expr.span;
        match (kind.value, expr.value.expr) {
            // If we're applying arithmetic negation to a numeric literal, negate
            // the literal value directly.
            (NegateKind::Arithmetic, Expr::Literal(Literal::Int32(n))) => {
                Expr::from(Literal::Int32(-n))
            }
            (_, expr) => {
                Expr::from(NegateExpr {
                    kind,
                    expr: Spanned::new(expr_span, expr)
                })
            }
        }
    }.into(),

    #[precedence(level = "1")]
    <expr:Spanned<PrecExpr>> "as" <type_:Spanned<Path>> =>
        Expr::from(CastExpr { expr: expr.map(|expr| expr.expr), type_ }).into(),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <lhs:Spanned<PrecExpr>> <kind:Spanned<CompareKind>>
    <rhs:Spanned<PrecExpr>> =>?
    {
        if !lhs.value.is_grouped {
            if let Expr::Compare(_) = lhs.value.expr {
                return Err(ParseError::User {
                    error: Spanned::new(kind.span, "comparison operators can't be chained"),
                });
            }
        }

        Ok(Expr::from(CompareExpr {
            kind,
            lhs: lhs.map(|lhs| lhs.expr),
            rhs: rhs.map(|rhs| rhs.expr),
        }).into())
    },

    #[precedence(level = "3")]
    #[assoc(side = "right")]
    <lhs:Spanned<PrecExpr>> "=" <rhs:Spanned<PrecExpr>> =>? {
        match lhs.value.expr {
            Expr::Var(lhs) => Ok(Expr::from(AssignExpr {
                lhs: lhs,
                rhs: rhs.map(|rhs| rhs.expr),
            }).into()),
            _ => Err(ParseError::User {
                error: Spanned::new(lhs.span, "can't assign to this expression"),
            }),
        }
    },
};

BlockKind: BlockKind = {
    "unsafe" => BlockKind::Unsafe,
};

NegateKind: NegateKind = {
    "-" => NegateKind::Arithmetic,
    "!" => NegateKind::Logical,
};

CompareKind: CompareKind = {
    "==" => CompareKind::Eq,
    "!=" => CompareKind::Neq,
    "<=" => CompareKind::Lte,
    ">=" => CompareKind::Gte,
    "<" => CompareKind::Lt,
    ">" => CompareKind::Gt,
};

Literal: Literal =
    <n:Int32Literal> => Literal::Int32(n);

Int32Literal: i32 =
    <digits:Spanned<r"[0-9]+">> =>? i32::from_str(digits.value).map_err(|error| ParseError::User {
        error: Spanned::new(digits.span, "number too large to fit in Int32"),
    });

Ident: Ident =
    <name:r"[A-Za-z_][A-Za-z0-9_]*"> => Ident::from(name);

Path: Path =
    <segments:(<Ident> "::")*> <segment:Ident> => iterate![..segments, segment].collect();

Spanned<Rule>: Spanned<Rule> =
    <start: @L> <value: Rule> <end: @R> =>
        Spanned::new(Span::new(start as RawIndex, end as RawIndex), value);

Box<Rule>: Box<Rule> =
    <value: Rule> =>
        Box::new(value);

Comma<Rule>: Vec<Rule> =
    <mut xs:(<Rule> ",")*> <x:Rule?> => {
        xs.extend(x);
        xs
    };

match {
    // Skip whitespace.
    r"\s*" => {},
    // Skip line comments.
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip block comments.
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {},
    _
}
