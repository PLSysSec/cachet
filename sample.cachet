enum ValueType {
  Double,
  Int32,
  Boolean,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
  fn typeOf(value: Value) -> ValueType;

  fn isObject(value: Value) -> Bool {
    Value::typeOf(value) == ValueType::Object
  }
  fallible fn toObject(value: Value) -> Object {
    guard Value::isObject(value);
    unsafe { Value::toObjectUnchecked(value) }
  }
  unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
  fn shapeOf(object: Object) -> Shape;

  fallible fn toNativeObject(object: Object) -> NativeObject {
    let shape = Object::shapeOf(object);
    let class = Shape::classOf(shape);
    guard Class::isNativeObject(class);
    unsafe { object as NativeObject }
  }
  
  fallible fn getFixedSlot(object: Object, slot: Int32) -> Value {
    let nativeObject = Object::toNativeObject(object);
    NativeObject::getFixedSlot(nativeObject, slot)
  }
}

struct NativeObject <: Object;

impl NativeObject {
  fallible fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
    let shape = Object::shapeOf(nativeObject);
    guard Shape::hasFixedSlot(shape, slot);
    unsafe { NativeObject::getFixedSlotUnchecked(nativeObject, slot) }
  }

  unsafe fn getFixedSlotUnchecked(nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
  fn classOf(shape: Shape) -> Class;

  fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
  fn isNativeObject(class: Class) -> Bool;
}

fallible op GuardToObject(value: Value, object: out Object) {
  object = Value::toObject(value);
}

fallible op GuardShape(object: Object, shape: Shape) {
  guard Object::shapeOf(object) == shape;
}

op LoadFixedSlotResult(object: Object, slot: Int32) -> Value {
  fallible { Object::getFixedSlot(object, slot) }
}
