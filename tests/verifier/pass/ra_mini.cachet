struct Range {
    lower_: Int32,
    upper_: Int32,
    hasInt32LowerBound_: Bool,
    hasInt32UpperBound_: Bool,
    canHaveFractionalPart_: Bool,
    canBeNegativeZero_: Bool,
    max_exponent_: UInt16,
}

unsafe fn mk_range_raw (
    lower_: Int32,
    upper_: Int32,
    hasInt32LowerBound_: Bool,
    hasInt32UpperBound_: Bool,
    canHaveFractionalPart_: Bool,
    canBeNegativeZero_: Bool,
    max_exponent_: UInt16,
) -> Range;

fn mk_range(
    lower_: Int32,
    upper_: Int32,
    hasInt32LowerBound_: Bool,
    hasInt32UpperBound_: Bool,
    canHaveFractionalPart_: Bool,
    canBeNegativeZero_: Bool,
    max_exponent_: UInt16,
) -> Range {
    let r = (unsafe {
        mk_range_raw(lower_, upper_, hasInt32LowerBound_, hasInt32UpperBound_, canHaveFractionalPart_, canBeNegativeZero_, max_exponent_)
    });

    assume r.lower_ == lower_;
    assume r.upper_ == upper_;
    assume r.hasInt32LowerBound_ == hasInt32LowerBound_;
    assume r.hasInt32UpperBound_ == hasInt32UpperBound_;
    assume r.canHaveFractionalPart_ == canHaveFractionalPart_;
    assume r.canBeNegativeZero_ == canBeNegativeZero_;
    assume r.max_exponent_ == max_exponent_;

    r
}


fn test() {
    let x = 4.0;
    let r = mk_range(
        0_i32,
        10_i32,
        true,
        true,
        false,
        false,
        4_u16,
    );

    assert in_range(r, x);
}


fn in_range(r: Range, n: Double) -> Bool {
    let mut ret = true;
    if (r.hasInt32LowerBound_ && n < Double::from_i32(r.lower_)) {
        ret = false;
    }

    if (r.hasInt32UpperBound_ && Double::from_i32(r.upper_) < n) {
        ret = false;
    }

    ret
}