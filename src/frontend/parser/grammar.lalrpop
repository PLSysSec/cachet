// vim: set tw=99 ts=4 sts=4 sw=4 et:

use codespan::{RawIndex, Span};
use iterate::iterate;

use crate::frontend::parser::ast::*;
use crate::frontend::parser::helpers::*;

grammar;

extern {
    type Error = UserParseError;
}

pub Spec: Spec = TopDef*;

TopDef: TopDef = {
    <enum_def:EnumDef> => enum_def.into(),
    <struct_def:StructDef> => struct_def.into(),
    <impl_def:ImplDef> => impl_def.into(),
    <const_def:ConstDef> => const_def.into(),
    <fn_def:FnDef> => fn_def,
};

EnumDef: EnumDef =
    "enum" <ident:Spanned<Ident>> "{" <variants:Comma<Spanned<Ident>>> "}" =>
        EnumDef { ident, variants };

StructDef: StructDef =
    "struct" <ident:Spanned<Ident>> <subtype_of:StructDefSubtypeOf?> ";" =>
        StructDef { ident, subtype_of };

StructDefSubtypeOf: Spanned<Path> =
    "<:" <ident:Spanned<Path>> => ident;

ImplDef: ImplDef =
    "impl" <parent_type:Spanned<Path>> "{" <top_defs:Spanned<TopDef>*> "}" =>? {
        let defs = top_defs.into_iter().map(|top_def| {
            match top_def.value {
                TopDef::Def(def) => Ok(def),
                _ => Err(ParseError::User {
                    error: Spanned {
                        span: top_def.span,
                        value: "definitions of this kind can't be nested under `impl`s",
                    },
                }),
            }
        }).collect::<Result<_, _>>()?;

        Ok(ImplDef { parent_type, defs })
    };

ConstDef: ConstDef =
    "const" <ident:Spanned<Ident>> ":" <type_:Spanned<Path>> ";" =>
        ConstDef { ident, type_ };

FnDef: TopDef =
    <attrs:Spanned<FnDefAttr>*> <kind:FnDefKind> <ident:Spanned<Ident>> "(" <param_vars:Comma<ParamVar>> ")" <ret:FnDefRet?> <body:Spanned<FnBody>> =>? {
        let (is_fallible, is_unsafe) = FnDefAttr::reduce(attrs.into_iter())?;

        let sig = Sig {
            ident,
            is_fallible: is_fallible.is_some(),
            param_vars,
            ret,
        };

        match kind {
            FnDefKind::Fn => {
                Ok(FnDef {
                    sig,
                    is_unsafe: is_unsafe.is_some(),
                    body: body.value,
                }.into())
            }
            FnDefKind::Op => {
                let body_span = body.span;
                let body = body.value.ok_or_else(|| ParseError::User {
                    error: Spanned {
                        span: body_span,
                        value: "op definitions must have a body",
                    }
                })?;

                if let Some(span) = is_unsafe {
                    return Err(ParseError::User {
                        error: Spanned {
                            span,
                            value: "op definitions can't be `unsafe`",
                        }
                    });
                }

                Ok(OpDef { sig, body }.into())
            }
        }
    };

FnDefKind: FnDefKind = {
    "fn" => FnDefKind::Fn,
    "op" => FnDefKind::Op,
};

FnDefAttr: FnDefAttr = {
    "fallible" => FnDefAttr::Fallible,
    "unsafe" => FnDefAttr::Unsafe,
};

FnDefRet: Spanned<Path> =
    "->" <type_:Spanned<Path>> => type_;

FnBody: Option<Spanned<Block>> = {
    ";" => None,
    <block:Spanned<Block>> => Some(block),
};

ParamVar: ParamVar =
    <ident:Spanned<Ident>> ":" <attrs:Spanned<ParamVarAttr>*> <type_:Spanned<Path>> =>? {
        let is_out = ParamVarAttr::reduce(attrs.into_iter())?.is_some();
        Ok(ParamVar { ident, is_out, type_ })
    };

ParamVarAttr: ParamVarAttr =
    "out" => ParamVarAttr::Out;

Block: Block = {
    "{" <stmts:Stmts> <value:Expr?> "}" => Block { stmts, value }, 
    "{" <value:BlockOrExpr?> "}" => Block { stmts: vec![], value },

    "{" <stmts_block:StmtsBlock> "}" => {
        let (stmts, block) = stmts_block;
        Block { stmts, value: Some(block.into()) }
    },
    "{" <stmts_block:StmtsBlock> <value:Expr> "}" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        Block { stmts, value: Some(value) }
    },
};

Stmts: Vec<Stmt> = {
    <stmt:Stmt> => vec![stmt],
    <stmts:Stmts> ";" => stmts,
    <mut stmts:Stmts> <stmt:Stmt> => {
        stmts.push(stmt);
        stmts
    },

    <block:Block> ";" => vec![block.into()],
    <block:Block> <stmt:Stmt> => vec![block.into(), stmt],

    <stmts_block:StmtsBlock> ";" => {
        let (mut stmts, block) = stmts_block;
        stmts.push(block.into());
        stmts
    },
    <stmts_block:StmtsBlock> <stmt:Stmt> => {
        let (mut stmts, block) = stmts_block;
        stmts.extend([block.into(), stmt]);
        stmts
    },
};

StmtsBlock: (Vec<Stmt>, Block) = {
    <stmts:Stmts> <block:Block> => (stmts, block),
    <prev_block:Block> <block:Block> => (vec![prev_block.into()], block),
    <stmts_block:StmtsBlock> <block:Block> => {
        let (mut stmts, prev_block) = stmts_block;
        stmts.push(prev_block.into());
        (stmts, block)
    },
};

Stmt: Stmt = {
    <let_stmt:LetStmt> => let_stmt.into(),
    <check_stmt:CheckStmt> => check_stmt.into(),
    <expr:Expr> ";" => expr.into(),
};

LetStmt: LetStmt =
    "let" <lhs:Spanned<Ident>> <type_:LetStmtType?> "=" <rhs:Spanned<BlockOrExpr>> ";" =>
        LetStmt { lhs, rhs, type_ };

LetStmtType: Spanned<Path> =
    ":" <type_:Spanned<Path>> => type_;

CheckStmt: CheckStmt =
    <kind:CheckStmtKind> <cond:Spanned<BlockOrExpr>> ";" => CheckStmt { kind, cond };

CheckStmtKind: CheckStmtKind = {
    "assert" => CheckStmtKind::Assert,
    "guard" => CheckStmtKind::Guard,
};

Expr: Expr = Expr0;

BlockOrExpr: Expr = {
    <block:Block> => block.into(),
    Expr0,
};

Expr0: Expr = {
    <assign_expr:AssignExpr> => assign_expr.into(),
    Expr1,
};

BlockOrExpr0: Expr = {
    <block:Block> => block.into(),
    Expr0,
};

Expr1: Expr = {
    <compare_expr:CompareExpr> => compare_expr.into(),
    Expr2,
};

BlockOrExpr1: Expr = {
    <block:Block> => block.into(),
    Expr1,
};

Expr2: Expr = {
    <cast_expr:CastExpr> => cast_expr.into(),
    VarOrCallExpr,
    <block_expr:BlockExpr> => block_expr.into(),
};

BlockOrExpr2: Expr = {
    <block:Block> => block.into(),
    Expr2,
};

VarOrCallExpr: Expr =
    <path:Spanned<Path>> <args:Spanned<CallExprArgs>?> => {
        match args {
            Some(args) => CallExpr {
                target: path,
                args,
            }.into(),
            None => path.into(),
        }
    };

BlockExpr: BlockExpr =
    <kind:BlockExprKind> <block:Block> => BlockExpr {
        kind: Some(kind),
        block,
    };

BlockExprKind: BlockExprKind = {
    "fallible" => BlockExprKind::Fallible,
    "unsafe" => BlockExprKind::Unsafe,
};

CastExpr: CastExpr =
    <expr:Spanned<BlockOrExpr2>> "as" <type_:Spanned<Path>> =>
        CastExpr { expr, type_ };

CompareExpr: CompareExpr =
    <lhs:Spanned<BlockOrExpr1>> <kind:Spanned<CompareExprKind>> <rhs:Spanned<BlockOrExpr2>> =>
        CompareExpr { kind, lhs, rhs };

CompareExprKind: CompareExprKind = {
    "==" => CompareExprKind::Eq,
    "!=" => CompareExprKind::Neq,
    "<=" => CompareExprKind::Lte,
    ">=" => CompareExprKind::Gte,
    "<" => CompareExprKind::Lt,
    ">" => CompareExprKind::Gt,
};

AssignExpr: AssignExpr =
    <lhs:Spanned<BlockOrExpr1>> "=" <rhs: Spanned<BlockOrExpr0>> =>? {
        match lhs.value {
            Expr::Var(lhs) => Ok(AssignExpr { lhs, rhs }),
            _ => Err(ParseError::User {
                error: Spanned {
                    span: lhs.span,
                    value: "can't assign to this expression"
                }
            }),
        }
    };

CallExprArgs: Vec<CallExprArg> =
    "(" <args:Comma<CallExprArg>> ")" => args;

CallExprArg: CallExprArg = {
    <expr:Spanned<BlockOrExpr>> => expr.into(),
    "out" <path:Spanned<Path>> => CallExprArg::OutRef(path),
    "out" "let" <ident:Spanned<Ident>> <type_:LetStmtType?> => LetOutRef { ident, type_ }.into(),
};

Ident: String =
    <name:r"[A-Za-z_][A-Za-z0-9_]*"> => name.to_owned();

Path: Path =
    <x:Ident> <y:PathSegment?> => {
        match y {
            Some(ident) => Path::new(Some(x), ident),
            None => Path::from_ident(x),
        }
    };

PathSegment: Ident =
    "::" <ident:Ident> => ident;

Spanned<Rule>: Spanned<Rule> =
    <start: @L> <value: Rule> <end: @R> =>
        Spanned::new(Span::new(start as RawIndex, end as RawIndex), value);

Comma<Rule>: Vec<Rule> =
    <xs:(<Rule> ",")*> <x:Rule?> => iterate![..xs, ..x].collect();

match {
    // Skip whitespace.
    r"\s*" => {},
    // Skip line comments.
    r"//[^\n\r]*[\n\r]*" => {},
    // Skip block comments.
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {},
    _
}
